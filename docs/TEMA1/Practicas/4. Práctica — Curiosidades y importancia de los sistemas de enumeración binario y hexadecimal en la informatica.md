# 4. Pr√°ctica ‚Äî Curiosidades y importancia de los sistemas de enumeraci√≥n binario y hexadecimal en la informatica.

Entrega en formato PDF los puntos; 2 y 3


## 1 Traduciendo a esamblador, da la instrucci√≥n de forma correcta en hexadecimal.

| N¬∫   | Instrucci√≥n a realizar                     | Registro/Dato  | Direcci√≥n en decimal | Direcci√≥n en hexadecimal |
| ---- | ------------------------------------------ | -------------- | -------------------- | ------------------------ |
| 1    | Mover un valor a un registro               | AX             | 4660                 | ?                        |
| 2    | Mover un valor desde memoria a un registro | BX             | 12345                | ?                        |
| 3    | Sumar un valor de memoria a un registro    | DX + \[Memory] | 54321                | ?                        |

MOV AX, [-]
MOV BX, [-]
ADD DX, [-]

Se pide  que completes las instrucciones anteriores con el n√∫mero hexadecimal correspondiente. Para ello, p√°salo primero a binario y despu√©s a hexadecimal.

---

## 2 Parte pr√°ctica Arquitectura de Von Neumaan resuelta.

Pila, simulaci√≥n pr√°ctica con los respectivos registros SS/SP

Supongamos:

- `SS = 5000h`
- `SP = 4000h`

Ejecuta estas instrucciones paso a paso y dibuja c√≥mo queda la pila en memoria y qu√© valor 	tienen `SP` y los registros afectados:

```bash
MOV AX, 1111h
PUSH AX
```

```bash
MOV BX, 2222h
PUSH BX
```

```bash
POP CX
```

```bash
POP DX
```

**<u>Soluci√≥n</u>**

1.Tras `PUSH AX`: `SP = 3FFEh`. Memoria:

- `5000:3FFE = 11h` (low)

- `5000:3FFF = 11h` (high)

  Estado:
   	AX=1111h, SP=3FFEh

---

2.Tras `PUSH BX`: `SP = 3FFCh`

- Memoria a√±adida:
  - `5000:3FFC = 22h` (low)
  - `5000:3FFD = 22h` (high)
- (Lo de AX sigue en 3FFE‚Äì3FFF)

‚Äã	Estado:
‚Äã	 AX=1111h, BX=2222h, SP=3FFCh

‚Äã	Pila (arriba = direcci√≥n mayor):

```makefile
5000:3FFC  22
5000:3FFD  22   ‚Üê BX (√∫ltimo en entrar, arriba del todo)
5000:3FFE  11
5000:3FFF  11   ‚Üê AX
```

---

3.Tras `POP CX`

- Saca la palabra de `[SS:3FFC..3FFD]` ‚áí CX = 2222h
- `SP = 3FFEh`

Estado:
 CX=2222h, SP=3FFEh
 (La memoria queda con los mismos bytes, pero esa zona ya est√° ‚Äúlibre‚Äù l√≥gicamente)

---

4.Tras `POP DX`

```makefile
Saca la palabra de [SS:3FFE..3FFF] ‚áí DX = 1111h
   
SP = 4000h (pila vac√≠a otra vez)
```

Estado final:

```makefile
AX = 1111h (no cambi√≥)
   
BX = 2222h (no cambi√≥)
   
CX = 2222h
   
DX = 1111h
   
SP = 4000h
   
SS = 5000h
```

Resumen de la traza de `SP: 4000h ‚Üí 3FFEh ‚Üí 3FFCh ‚Üí 3FFEh ‚Üí 4000h`
Y el orden LIFO se cumple: lo √∫ltimo en entrar (BX) fue lo primero en salir (CX).

---

### 3 Parte pr√°ctica Arquitectura de Von-Newman sin resolver (Ejercicio opcional para subida nota)

Supongamos:

- `SS = 6000h`
- `SP = 2000h`

Ejecuta paso a paso y dibuja c√≥mo queda la pila (memoria, SP y registros) despu√©s de cada instrucci√≥n:

```
MOV AX, 1234h
PUSH AX
```
```
MOV BX, 5678h
PUSH BX
```
```
POP CX
```

```
POP DX
```

¬øQu√© ocurre si haces m√°s `PUSH` de los que caben en el segmento de pila reservado (por ejemplo, si reservas 16 KB y empujas 20 KB)?

¬øQu√© problema real se genera? ¬øPor qu√© la pila crece hacia direcciones menores en memoria en lugar de hacia arriba?

## 4 Codificaciones de textos

El texto que ves en tu pantalla no es m√°s que una codificaci√≥n del lenguaje binario. Todo lo que se muestra en la pantalla, ya sean letras, n√∫meros o s√≠mbolos, se traduce finalmente a ceros y unos, que la computadora puede interpretar.
A lo largo de la historia de la inform√°tica, se han desarrollado distintas codificaciones de caracteres para representar texto en binario: EBCDIC, ASCII,Extended ASCII y Unicode,

Establece una linea temporal de las distintas codificaciones, dando ejemplos y el n√∫mero de bits que utliza cada una as√≠ como el n√∫mero total de caracteres posibles. Si un tipo de codificaci√≥n admit√≠a hasta 7 bits: ¬øcu√°l es la cantidad de car√°cteres admitidos en total?

| Car√°cter | UTF-8 (binario)              | Unicode (hexadecimal) |
| -------- | ---------------------------- | --------------------- |
| A        | `01000001`                   | (rellenar)            |
| √±        | `11000011 10110001`          | (rellenar)            |
| ‚Ç¨        | (rellenar)                   | U+20AC                |
| üòÇ        | (rellenar)                   | U+1F602               |
| ‰∏≠       | `11100100 10111000 10101101` | (rellenar)            |

## 5 L√≠mite RAM

En la arquitectura x86 de 32 bits, los ordenadores ten√≠an un l√≠mite te√≥rico de 4GB de ram, ¬øpor qu√©?, ¬øde qu√© operaci√≥n sale ese n√∫mero?, ¬øcu√°l es el l√≠mite te√≥rico a d√≠a de hoy que otorga los procesadores de 64 bits y por qu√©? ¬øY los ordenadores de 16 bits?

## 6 Explorando el hardware del ordenador

1- Ejecuta 

```bash
lscpu
```

- ¬øCu√°ntos **n√∫cleos f√≠sicos** 

- ¬øCu√°ntos **procesadores l√≥gicos** aparecen? ¬øCoinciden con los n√∫cleos f√≠sicos o hay HyperThreading/SMT activado?

2- Con el comando:

```bash
cat /proc/cpuinfo | grep "model name" | uniq
```

- ¬øQu√© modelo de CPU tienes?
- ¬øA cu√°ntos GHz est√° configurada la frecuencia base?

3- Ejecuta:

```bash
free -h
```

- ¬øCu√°nta memoria RAM total reconoce tu sistema?
- ¬øCu√°nta est√° en uso y cu√°nta libre?
- ¬øQu√© es la memoria Swap y como la podemos ver? Ejecuta para ello:`grep Swap /proc/meminfo`

Desde la interfaz gr√°fica (Configuraci√≥n ‚Üí Acerca de este equipo):

- Comprueba si el valor de RAM coincide con el reportado en la terminal.

