# 4. Pr√°ctica ‚Äî Curiosidades y importancia de los sistemas de enumeraci√≥n binario y hexadecimal en la informatica.

Entrega en formato PDF los puntos; 4.2 y 4.3

## 4.1 Traduciendo a esamblador, da la instrucci√≥n de forma correcta en hexadecimal.

<u>Soluci√≥n</u>

Lo √∫nico que se ped√≠a era el paso a hexadecimal, nada m√°s...
Ahora bien, este ejercicio requer√≠a una m√≠nima explicaci√≥n de lo que hac√©is, y as√≠ se valorar√°.

| N¬∫   | Instrucci√≥n a realizar                     | Registro/Dato | Direcci√≥n en decimal | Direcci√≥n en hexadecimal | Instrucci√≥n en ensamblador |
| ---- | ------------------------------------------ | ------------- | -------------------- | ------------------------ | -------------------------- |
| 1    | Mover un valor a un registro               | AX            | 4660                 | 1234h                    | MOV AX, 1234h              |
| 2    | Mover un valor desde memoria a un registro | BX            | 12345                | 3039h                    | MOV BX, [3039h]            |
| 3    | Sumar un valor de memoria a un registro    | DX + [Memory] | 54321                | D431h                    | ADD DX, [D431h]            |



## 4.2 Parte pr√°ctica Arquitectura de Von Neumaan resuelta.

Este ejercicio ya estaba resuelto, lo dejo tal y como estaba ya que era un ejemplo.

### 4.3 Parte pr√°ctica Arquitectura de Von-Newman sin resolver (Ejercicio opcional para subida nota)

Supongamos:

- `SS = 6000h`
- `SP = 2000h`

Ejecuta paso a paso y dibuja c√≥mo queda la pila (memoria, SP y registros) despu√©s de cada instrucci√≥n:

```
MOV AX, 1234h
PUSH AX
```
```
MOV BX, 5678h
PUSH BX
```
```
POP CX
```

```
POP DX
```

Vamos con la soluci√≥n, paso a paso de lo que hay que hacer, ¬°RECUERDO QUE ESTE EJERCICIO ERA OPCIONAL!

- ------

  Primer paso, ejercuci√≥n del PUSH y retroceso de SP

  ```makefile
  6000:1FFE  34     AX low
  6000:1FFF  12     AX high
  SP=1FFEh
  ```

Segundo paso, segundo PUSH (las cosas se apilan como una PILA, por eso se llama as√≠)

```makefile
6000:1FFC  78   BX low
6000:1FFD  56   BX high
6000:1FFE  34   AX low
6000:1FFF  12   AX high
SP=1FFCh
```

Tercer paso, primer POP

```makefile
Saca 2 bytes (16 bits al registro CX) 

Luego saca dos registros de memoria de arriba a abajo [SS:1FFC,1FFD] 
eso va al registro CX = 5678h

Estado de los registros: CX=5678h, SP=1FFEh
```

Cuarto paso, segundo POP

```makefile
Saca 2 bytes (16 bits al registro DX) 

Luego saca dos registros de memoria de arriba a abajo [SS:1FFE,1FFF] 
eso va al registro DX = 1234h

Estado de los registros: CX=5678h, SP=1FFEh, DX=1234h
Estado final: AX=1234h, BX=5678h (no cambian), CX=5678h, DX=1234h, SP=2000h, SS=6000h
```

Por √∫ltimo, la traza:

```makefile
Traza de SP: 2000h ‚Üí 1FFEh ‚Üí 1FFCh ‚Üí 1FFEh ‚Üí 2000h
```

¬øQu√© ocurre si haces m√°s `PUSH` de los que caben en el segmento de pila reservado (por ejemplo, si reservas 16 KB y empujas 20 KB)?

Stack-Overflow :)

Con esto, bastaba.



¬øQu√© problema real se genera? ¬øPor qu√© la pila crece hacia direcciones menores en memoria en lugar de hacia arriba?

El programa intenta guardar m√°s datos de los que caben/se pueden en ella, provocando distintos tipos de errores dependiendo del contexto.

Convenci√≥n: La pila crece hacia abajo por una convenci√≥n de dise√±o tomada, nada m√°s. 

Por ejemplo, la pila crece desde las direcciones altas hacia abajo, el heap (otra zona, buscadla si no sab√©is cual es, donde se guardan datos temporales) crece en direcci√≥n contraria.

## 4.4 Codificaciones de textos

El texto que ves en tu pantalla no es m√°s que una codificaci√≥n del lenguaje binario. Todo lo que se muestra en la pantalla, ya sean letras, n√∫meros o s√≠mbolos, se traduce finalmente a ceros y unos, que la computadora puede interpretar.
A lo largo de la historia de la inform√°tica, se han desarrollado distintas codificaciones de caracteres para representar texto en binario: EBCDIC, ASCII,Extended ASCII y Unicode,

Establece una linea temporal de las distintas codificaciones, dando ejemplos y el n√∫mero de bits que utliza cada una as√≠ como el n√∫mero total de caracteres posibles. Si un tipo de codificaci√≥n admit√≠a hasta 7 bits: ¬øcu√°l es la cantidad de car√°cteres admitidos en total?

<u>Soluci√≥n tabla</u>
Este ejercico con la tabla ten√≠a bastante truco, pero la idea era que como sois adultos e independientes, buscaseis informaci√≥n al respecto.Se divide en dos casos distintos la soluci√≥n:

En el caso en que el n√∫mero binario sea de 8bits, es decir 1 byte, (o en caso de que el n√∫mero en hexadecimal tenga dos ceros delante,) s√≥lo ten√©is que transforma a Binario o al rev√©s.
Por ejemplo:

En el caso de la A, yo os daba: 01000001. Para pasarlo a UNICODE, s√≥lo teneis que pasarlo a decimal:

```text
01000001=0100|0001= U+0041
```

---

En el caso de que que el n√∫mero tenga dos bytes (o que en hexadecimal tiene el siguiente rango de valores: U+0080 ‚Äì U+07FF), ten√©is que tener en cuenta el siguiente patr√≥n que siguen en binario. 

```text
110xxxxx 10xxxxxx (por tanttenga do hay 11 caracteres variables, que son las "x")
```

Lo que quiere decir que, en el caso de la √±, yo os daba 11000011 10110001, que son solo 8 y no 11.

```text
11000011 10110001-> Nos quedamos "solo con las x": 110|00011 10|110001= 00011110001 (quitos los 0's a la izquierda) = 11110001
```

Pasando este n√∫mero a hexadecimal, me queda F1

---

En el caso de que que el n√∫mero tenga tres bytes (o que en hexadecimal tiene el siguiente rango de valores: U+0800 ‚Äì U+FFFF), ten√©is que tener en cuenta el siguiente patr√≥n que siguen en binario. 

```text
1110xxxx 10xxxxxx 10xxxxxx (por tanto hay 16 caracteres variables, que son las "x")
```

En el caso de U+20AC est√° en este rango, (tambi√©n podemos pensar que al pasarlo a binario son 16 bits, luego por el patr√≥n de las "X" solo puede ser un n√∫mero de tres bytes en utf-8) luego sabemos que tiene 3 bytes. Pasamos 20AC a binario

```text
20AC = 0010|0000|1010|1100=0010000010101100 
```

Metiendo este n√∫mero en las "X" de antes (de izq a derecha), nos queda:
```text
11100010 10000010 10101100
```

---

En el caso de que que el n√∫mero tenga cuatro bytes (o que en hexadecimal tiene el siguiente rango de valores: U+10000 ‚Äì U+10FFFF), ten√©is que tener en cuenta el siguiente patr√≥n que siguen en binario. 

```text
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (por tanttenga do hay 21 caracteres variables, que son las "x")
```

Lo que quiere decir que, en el caso del emoji, yo os daba U+1F602,. Si passamos este n√∫mero a binario nos quedan 20 bits, pero con 1 cero a la izq llegamos a 21, por tanto no queda otra que ser un n√∫mero de 4bytes en UTF-8.

```text
U+1F602= 0001|1111|0110|0000|0010. Si a√±adimos un 0 a la izq nos queda :  0|0001|1111|0110|0000|0010.
```

Si metemos el n√∫mero final en las X, nos queda como resultado:
```text
11110000 10011111 10011000 10000010
```

---

El caso de ‰∏≠= 11100100 10111000 10101101 es simplemente pasar a hexadecimal.

Al final, la tabla rellena es la siguiente

| Car√°cter | UTF-8 (binario)                     | Unicode (hexadecimal) |
| -------- | ----------------------------------- | --------------------- |
| A        | 01000001                            | U+0041                |
| √±        | 11000011 10110001                   | U+00F1                |
| ‚Ç¨        | 11100010 10000010 10101100          | U+20AC                |
| üòÇ        | 11110000 10011111 10011000 10000010 | U+1F602               |
| ‰∏≠       | 11100100 10111000 10101101          | U+4E2D                |

<u>Soluci√≥n</u> (de las preguntas)

B√°sicamente lo que ped√≠a en clase, es hacer una l√≠nea cronol√≥gica y saber el n√∫mero de bits (y en consecuencia el n√∫mero de caract√©res totales) que teb√≠a cada codificaci√≥n incluido UTF-8 UTF-16 y UTF-32 dentro de UNICODE, aunque primero una introducc√≥n:

A lo largo de la historia de la inform√°tica, las codificaciones de caracteres han evolucionado para adaptarse a las necesidades de comunicaci√≥n entre humanos y computadoras. Cada sistema de codificaci√≥n ha buscado una manera eficiente de representar letras, n√∫meros y s√≠mbolos mediante combinaciones de bits, permitiendo que los equipos electr√≥nicos comprendan y transmitan informaci√≥n textual.

Y ahora, empezamos con un peque√±o desarrollo cronol√≥gico y los detalles m√°s importante, para cada una:

- En la d√©cada de 1950, IBM desarroll√≥ la codificaci√≥n <u>EBCDIC (Extended Binary Coded Decimal Interchange Code),</u> la cual utilizaba <u>8 bits</u> por car√°cter, permitiendo representar <u>256 caracteres posibles</u>. Fue ampliamente usada por IBM (buscadala si no sab√©is que empresa es), aunque result√≥ incompatible con ASCII, el estandar que veremos justo a continucaci√≥n. Por curiosidad, un ejemplo es la letra ‚ÄúA‚Äù, que se codificaba como 11000001.

- Posteriormente, en 1963, surgi√≥ <u>ASCII (American Standard Code for Information Interchange)</u>, una codificaci√≥n <u>de 7 bits</u> que permit√≠a representar <u>128 caracteres diferentes</u>. Este est√°ndar se convirti√≥ en la base de la comunicaci√≥n digital, incluyendo letras del alfabeto ingl√©s, n√∫meros, signos de puntuaci√≥n y algunos caracteres de control. Por ejemplo, la letra ‚ÄúA‚Äù se representa en ASCII como 01000001 (como pod√©is ver, distinto a la codificaci√≥n EBDIC).

- Durante los a√±os 80, para incluir caracteres que permitiesen tildes y s√≠mbolos propios de los idiomas europeos (como en espa√±ol la √±), se cre√≥ el <u>Extended ASCII</u> o ISO 8859-1 (denominado Latin-1). En este punto, como pod√©is ver entra en juego la terminolog√≠a "ISO" (International Organization for Standardization), es decir, la Organizaci√≥n Internacional de Normalizaci√≥n. Fundada en 1947 y con sede en Ginebra y se encarga de establecer normas internacionales que faciliten la interoperabilidad entre tecnolog√≠as y pa√≠ses. En el √°mbito inform√°tico, ISO defini√≥ la serie de normas <u>ISO/IEC 8859, que especifican distintos conjuntos de caracteres de 8 bits</u>, adaptados a los s√≠mbolos de diversas regiones del mundo. Aqu√≠ os dejo un peque√±o resumen, que no ten√©is por qu√© saber pero s√≠ es muy interesante que os suene.
  - **ISO 8859-1 (Latin-1):** Europa Occidental : incluye ‚Äú√±‚Äù, ‚Äú√°‚Äù, ‚Äú√©‚Äù, ‚Äú√∂‚Äù y otras m√°s
  - **ISO 8859-5:** Alfabetos cir√≠licos.
  - **ISO 8859-6:** √Årabe.
  - **ISO 8859-7:** Griego.

- Finalmente, en 1991, el √∫ltimo de todos, <u>Unicode</u>, una codificaci√≥n universal que <u>buscaba representar todos los caracteres de todos los idiomas</u> (es decir, la "unificaci√≥n de todo lo anterior"), adem√°s de la posibilidad de a√±adir y escribir s√≠mbolos matem√°ticos o incluso emojis. 

  - Unicode <u>utiliza un n√∫mero variable de bits (entre 8 y 32 bits</u>) seg√∫n el formato empleado (UTF-8, UTF-16 o UTF-32 que  tratan de diferentes m√©todos de codificaci√≥n binaria que veremos un poquito a continuaci√≥n), y admite m√°s de 1,100,000 caracteres posibles pero s√≥lo se llegan a usar 150 mil porque no necesita tantos. 

  - El formato UTF-8 <u>usado especialmente en Internet</u> (saber esto), y <u>compatible con ASCI</u>I. Su tama√±o es variable, pues puede <u>usar entre 1 y 4 bytes</u> por car√°cter (lo hemos visto al resolver el ejercicio): un solo byte para los caracteres latinos b√°sicos (como las letras e incluso n√∫meros no flotantes) y hasta cuatro bytes para s√≠mbolos m√°s espec√≠ficos, como emojis.

  - UTF-16 tambi√©n tiene un tama√±o variable, <u>utilizando 2 bytes para la mayor√≠a de los caracteres comunes y 4 bytes</u> de nuevo para aquellos m√°s complejos, como los emojis (igual que antes). Este formato se emplea frecuentemente en sistemas Windows y en algunos entornos de programaci√≥n. En este caso, la letra ‚ÄúA‚Äù se codifica como 00000000 01000001, es decir, dos bytes a diferencia de UTF-8.

  - Finalmente, UTF-32 es un formato de longitud fija, en el que cada car√°cter ocupa <u>e</u><u>xactamente 4 bytes (32 bits)</u>. Esto simplifica la lectura y el procesamiento de los datos, ya que <u>cada car√°cter tiene el mismo tama√±o en memoria</u>, pero tambi√©n implica un mayor consumo de espacio

  - Unicode se convirti√≥ oficialmente en la norma ISO/IEC 10646 <u>que son las normas vigentes y actualmente utilizadas en todo el mundo para la codificaci√≥n universal de caracteres</u>,  en donde IEC significa International Electrotechnical Commission, o en espa√±ol, Comisi√≥n Electrot√©cnica Internacional que  se encarga de elaborar y publicar normas internacionales relacionadas con la electricidad, la electr√≥nica y las tecnolog√≠as asociadas.

## 4.5 L√≠mite RAM

En la arquitectura x86 de 32 bits, los ordenadores ten√≠an un l√≠mite te√≥rico de 4GB de ram, ¬øpor qu√©?, ¬øde qu√© operaci√≥n sale ese n√∫mero?, ¬øcu√°l es el l√≠mite te√≥rico a d√≠a de hoy que otorga los procesadores de 64 bits y por qu√©? ¬øY los ordenadores de 16 bits? Basta seguir la siguiente f√≥rmula (razonada en la pizarra en clase por mi, pero pod√©is aprenderosla de memoria):

$$
\text{Memoria direccionable} = 2^{\text{n√∫mero de bits de direcci√≥n}}
$$
Donde en el caso de n=32 tenemos::

- n = 32:  2¬≥¬≤ = 4,294,967,296 bytes = 4 GB

Ahora bien, en el caso de n=16 tendr√≠amos algo as√≠:

- n = 16 : 2¬π‚Å∂ = 65,536 bytes = 64 KB

Ahora bien, en el caso de n=64 tendr√≠amos algo as√≠:

- n = 64 : 2‚Å∂‚Å¥ = 16,777,216 TB = 16 exabytes

## 4.6 Explorando el hardware del ordenador

1- Ejecuta 

```bash
lscpu
```

- ¬øCu√°ntos n√∫cleos f√≠sicos 

- ¬øCu√°ntos procesadores l√≥gicos aparecen? ¬øCoinciden con los n√∫cleos f√≠sicos o hay HyperThreading/SMT activado?

  <u>Soluci√≥n</u>:

  ![image-20251011172740916](/home/manolo/.config/Typora/typora-user-images/image-20251011172740916.png)



En mi caso, 6 n√∫cleos f√≠sicos, 2 hilos por nucleo (por el hyperthrading) luego 12 n√∫cleos l√≥gicos en total.

En la mayot√≠a de vosotros, asignasteis "2 CPU'S" en la MV, por tanto, lo que os aparecer√° es "2 n√∫celos fisicos", "1 hilo por n√∫cleo". En realidad, vosotros le dais a la m√°quina 2 n√∫cleos l√≥gicos, no f√≠sicos, pero ella los interpreta siempre como f√≠sicos.

2- Con el comando:

```bash
cat /proc/cpuinfo | grep "model name" | uniq
```

- ¬øQu√© modelo de CPU tienes?

  Poner el modelo de CPU que os salga, en mi caso:

  ![image-20251011171842253](/home/manolo/.config/Typora/typora-user-images/image-20251011171842253.png)

  

- ¬øA cu√°ntos GHz est√° configurada la frecuencia base? 

  Buscarlo en internet, yo comprobar√© que lo hagais bien.

3- Ejecuta:

```bash
free -h
```

- ¬øCu√°nta memoria RAM total reconoce tu sistema?

  ![image-20251011171927682](/home/manolo/.config/Typora/typora-user-images/image-20251011171927682.png)

- ¬øCu√°nta est√° en uso y cu√°nta libre?

  Lo que se ve en la captura

- ¬øQu√© es la memoria Swap y como la podemos ver? Ejecuta para ello:`grep Swap /proc/meminfo`

  La memoria Swap es una parte del disco duro que el sistema usa como memoria RAM adicional cuando esta se llena.

  ![image-20251011172031696](/home/manolo/.config/Typora/typora-user-images/image-20251011172031696.png)

  En mi caso, tengo la memoria Swap desactivada, mas que nada porque tengo procesos que impiden que est√© activa. Ya veremos cuando llegue el momento bajo que casu√≠sticas se debe desactivar.

- Comprueba si el valor de RAM coincide con el reportado en la terminal.

  No coincide: El primer valor indica la memoria f√≠sica total instalada en el equipo (en mi caso incluso aument√© la ram de mi ordenador), mientras que la captura que aqu√≠ pongo da la cantidad de memoria utilizada por el sistema. Una parte de la RAM se reserva para el hardware o la BIOS por eso no me aparece lo mismo con el comando de terminal. Si me adjuntais caputura de que no coinciden, os lo pondr√© bien.