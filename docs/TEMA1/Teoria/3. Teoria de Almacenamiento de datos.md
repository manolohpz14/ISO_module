# 3. Teoria de Almacenamiento de datos

Veamos la teoría de este punto 3.

## 1. Unidades de medida de la información

En informática, la información se mide en bits y sus múltiplos. Las unidades de medida permiten cuantificar la capacidad de almacenamiento o el tamaño de datos.

**1.Bit:** Símbolo: b, es la unidad mínima de información con valores posibles 0 o 1. Representa un estado lógico, verdadero/falso, encendido/apagado.

**2.Byte:** Símbolo: B, representa un conjunto de 8 bits con rango de valores: 0 a 255 (2⁸ posibles combinaciones). Puede representar un carácter de texto, un valor numérico pequeño o un color de 8 bits.

**3.Resto de medidas**: Miramos la siguiente tabla:


| Unidad decimal (SI) | Símbolo | Equivalencia decimal (base 10)   | Unidad binaria (IEC) | Símbolo | Equivalencia binaria (base 2)           | Uso típico                        |
| ------------------- | ------- | -------------------------------- | -------------------- | ------- | --------------------------------------- | --------------------------------- |
| Kilobyte            | kB      | 10³ bytes = 1.000 B              | Kibibyte             | KiB     | 2¹⁰ bytes = 1.024 B                     | Pequeños archivos de texto        |
| Megabyte            | MB      | 10⁶ bytes = 1.000.000 B          | Mebibyte             | MiB     | 2²⁰ bytes = 1.048.576 B                 | Archivos de música, imágenes      |
| Gigabyte            | GB      | 10⁹ bytes = 1.000.000.000 B      | Gibibyte             | GiB     | 2³⁰ bytes = 1.073.741.824 B             | Memoria RAM, discos duros         |
| Terabyte            | TB      | 10¹² bytes = 1.000.000.000.000 B | Tebibyte             | TiB     | 2⁴⁰ bytes ≈ 1.099.511.627.776 B         | Almacenamiento masivo, servidores |
| Petabyte            | PB      | 10¹⁵ bytes                       | Pebibyte             | PiB     | 2⁵⁰ bytes ≈ 1.125.899.906.842.624 B     | Centros de datos muy grandes      |
| Exabyte             | EB      | 10¹⁸ bytes                       | Exbibyte             | EiB     | 2⁶⁰ bytes ≈ 1.152.921.504.606.846.976 B | Internet global (estimaciones)    |

---

## 2. Ejemplos de conversiones decimales

#### - De kilobytes a megabytes

$$
1 \, \text{MB} = 10^6 \, \text{B}, \quad 1 \, \text{kB} = 10^3 \, \text{B}
$$

------

#### - De gigabytes a terabytes

$$
1 \, \text{GB} = 10^9 \, \text{B}, \quad 1 \, \text{TB} = 10^{12} \, \text{B}
$$

------

## 3. Ejemplos de conversiones binarias

#### - De Kibibytes a Mebibytes

$$
1 \, \text{KiB} = 2^{10} \, \text{B}, \quad 1 \, \text{MiB} = 2^{20} \, \text{B}
$$

------

#### - De Gibibytes a Tebibytes

$$
1 \, \text{GiB} = 2^{30} \, \text{B}, \quad 1 \, \text{TiB} = 2^{40} \, \text{B}
$$

------

## 4. Ejemplos de conversiones cruzadas

#### - De Gibibytes a Gigabytes

$$
1 \, \text{GiB} = 2^{30} \, \text{B}, \quad 1 \, \text{GB} = 10^9 \, \text{B}
$$

$$
10 \, \text{MB} = \frac{10 \times 10^6}{2^{20}} \approx 9,54 \, \text{MiB}$
$$

---

## 5. Formas de guardar la información

- Cuando hablamos de cómo se guarda la información en un ordenador, siempre debemos volver a lo esencial: todo se reduce a bits, ceros y unos. Estos valores, que representan estados eléctricos o magnéticos, necesitan un soporte físico en el que almacenarse para que el sistema pueda conservarlos incluso cuando se apaga la máquina.

- Durante décadas, ese soporte ha sido el disco duro mecánico o HDD. Un HDD funciona con platos recubiertos de material magnético que giran a gran velocidad. Un cabezal de lectura y escritura se desplaza sobre esos platos, cambiando la orientación de pequeñísimas zonas magnéticas para representar un 0 o un 1. La información no se almacena de forma caótica, sino organizada en sectores (unidades mínimas de almacenamiento, normalmente de 512 bytes o 4 KB), que a su vez forman pistas. Esta organización permite que el sistema operativo localice y lea los datos de manera ordenada.

![imagen disco hdd](https://upload.wikimedia.org/wikipedia/commons/a/ae/Disk-structure2.svg)

- Más recientemente aparecieron los SSD o discos de estado sólido, que funcionan de una manera completamente diferente. En lugar de partes mecánicas y magnéticas, los SSD utilizan memoria flash NAND. Cada bit de información queda guardado como una carga eléctrica dentro de transistores microscópicos. La ventaja fundamental es que no hay partes móviles: la lectura y escritura es casi instantánea y mucho más fiable a largo plazo frente a golpes o vibraciones. La información se organiza en páginas (que suelen ser de 4 a 16 KB). Esas páginas no están sueltas: se agrupan en bloques, normalmente de 1 MB (varias páginas juntas), pero el principio sigue siendo el mismo: representar ceros y unos que luego el sistema operativo agrupa en archivos y carpetas. El borrado siempre se hace a nivel de bloque completo, es decir, la unidad mínima de borrado es 1MB.


- Y aquí entra en juego una herramienta clásica de Linux: el comando dd. Este programa trabaja copiando datos a bajo nivel, en bloques cuyo tamaño puede configurarse con el parámetro bs (block size). Si usas dd con un tamaño de bloque alineado con las páginas o bloques físicos del SSD (por ejemplo, 4K o 1M), el rendimiento será mucho mejor. Si eliges tamaños muy pequeños (1K, 512 bytes), el SSD tiene que hacer más operaciones internas.

  -En un SSD, la unidad mínima física de escritura es la página (4 KB – 16 KB).

  -Si usas dd con un tamaño de bloque (bs) que coincide con la página física (por ejemplo, 4K), la escritura se alinea bien y es eficiente. Supongamos que quiero llenar un SSD con datos de prueba:

  - if = input file (/dev/urandom, datos aleatorios).

  - of = output file (prueba.img).

  - bs=1M → escribo en bloques de 1 MB.

  - Esto coincide bastante con el tamaño de un bloque interno del SSD (≈128 páginas de 8K = 1 MB).

Veamos un ejemplo, como decíamos, el comando dd se usa en Linux/Unix para copiar datos a bajo nivel, por ejemplo, grabar una ISO de Ubuntu en una memoria USB. Vamos a ver un ejemplo de cómo hacerlo:

```bash
sudo dd if=~/Descargas/ubuntu.iso of=/dev/sdX bs=4M status=progress conv=fsync
```
donde /dev/sdX es nuestro pendrive, buscado gracias a lsblk.



## 6. Consola. Linea de comandos.

La interfaz de línea de comandos, en inglés Command Line Interface o CLI, es el conjunto de elementos visuales que permiten, sobre un dispositivo de salida, indicar órdenes o comandos utilizando un dispositivo de entrada. Concretamente se utiliza el teclado para invocar comandos configurados para realizar una serie de acciones y el resultado de la ejecución de estas acciones se mostrará por pantalla.

En cualquier CLI se pueden encontrar los siguientes elementos, que se estudian con el caso concreto de un terminal Linux (figura 1.13):

- Prompt de usuario: indica el nombre del usuario (fer), el nombre de la máquina (fer-pc), el directorio en el que se encuentra actualmente (~/Documentos) y si el usuario tiene permisos de administrador (#) o es un usuario corriente ($).

- Comando: programa que va a ejecutar el usuario (echo).

- Parámetros: valores de configuración que se dan al programa (“Hola ISO”). Un tipo de parámetros especiales son los flags (también llamado opción o switch) es un parámetro que se añade a un comando para modificar su comportamiento.

- Operadores: elementos para enlazar la salida de un programa con la entrada de otro o con la escritura de datos en ficheros.

- Salida: datos o información que ofrece el programa como resultado de su procesamiento.

## 7 Ejemplos en ubuntu:
Uno de los comandos más comunes que veremos cuando listemos la estructura de un directorio en linux (siguiente tema), será el comando ls. En los siguientes ejemplos se muestran casos sencillos de uso dividiendo en la terminología usada anteriormente. La estructura de directorio de un debion también se verá en el siguiente tema y no debe ser objeto de preocupación del alumnado.

#### Ejemplo 1: ls simple

```bash
fer@pc:~/Documentos$ ls
```

Prompt de usuario: fer@pc:~/Documentos$

Comando: ls

Parámetro: (ninguno en este caso)

Operadores: (ninguno)

Salida: lista de archivos del directorio actual, ej.:
- informe.txt
- tareas.pdf
- notas.csv

#### Ejemplo 2: ls con parámetro (otro directorio)

```bash
fer@pc:~$ ls /etc
```

Prompt de usuario: fer@pc:~$

Comando: ls

Parámetro: /etc (indico el directorio que quiero listar)

Operadores: (ninguno)

Salida:
-hosts
-passwd
-shadow
-ssh


#### Ejemplo 3: ls con flag (parámetro especial)

```bash
fer@pc:~/Descargas$ ls -l
```

Prompt de usuario: fer@pc:~/Descargas$

Comando: ls

Parámetro (flag): -l (listado largo)

Operadores: (ninguno)

Salida:
```bash
-rw-r--r-- 1 fer fer  1024 sep  1 10:00 informe.txt
drwxr-xr-x 2 fer fer  4096 sep  2 11:30 proyectos
```


#### Ejemplo 4: ls con operador de redirección

```bash
fer@pc:~$ ls /bin > lista.txt
```

Prompt de usuario: fer@pc:~$

Comando: ls

Parámetro (flag): /bin

Operadores: > (redirige la salida a un archivo)

Salida: no se muestra nada en pantalla; se guarda en lista.txt.