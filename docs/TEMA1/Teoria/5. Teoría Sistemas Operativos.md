# Sistemas Operativos

## 1-Objetivos del Sistema Operativo

Desde el punto de vista del usuario, el sistema operativo consiste en una  serie de programas y funciones que ocultan los detalles del  hardware,ofreciéndole una vía sencilla y flexible de acceso al mismo,  teniendo dos objetivos fundamentales:

---

### 1.1 Seguridad

El sistema operativo debe actuar contra cualquier manipulación extraña, ya sea accidental o premeditada que pudiera dañar la información,  perjudicar a otros usuarios o provocar un funcionamiento indeseado del  sistema. Por ejemplo, hay ciertas instrucciones que pueden parar la  máquina y otras que realizan operaciones directamente sobre el hardware, que debemos evitar que se utilicen por los programas. Para ello,  algunos sistemas proporcionan dos estados, llamados estado protegido  (Sistema o `Kernel`), en el cual se ejecuta el sistema operativo, y estado no protegido (Usuario o User), que es el destinado a la ejecución de los programas de usuario y de aplicación. De esta  manera se impide que los programas de los usuarios puedan tener contacto directo con el hardware, o puedan forzar un incorrecto funcionamiento  del sistema.

![image-20251207185733576](../../img/image-20251207185733576.png)

---

### 1.2 Abstracción

La tendencia actual del software y de los lenguajes de programación es ocultar lo más posible los detalles de más bajo nivel, intentando dar a  los niveles superiores una visión más sencilla, global y abstracta,  ofreciéndoles operaciones para manipular dichas estructuras ocultas,  desconociendo por completo la gestión interna de las mismas. Sobre estas estructuras se construyen otras que abstraen a las anteriores, y así  sucesivamente. Gracias a la abstracción, los sistemas operativos  enmascaran los recursos físicos, permitiendo su manejo con funciones más generales que ocultan las básicas, constituyendo verdaderos recursos  ficticios o virtuales, que mejoran y son más potentes que los físicos.  Desde el punto de vista de un programa o usuario, la máquina física se  convierte, en una máquina extendida, que presenta la ventaja respecto a  la física de ofrecer más funciones de las que normalmente soportaría  esta última. Entre las posibilidades de esto estarían las carpetas  compartidas, los usuarios de red, las impresoras compartidas, etc.

[![Abstraccion del HW](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/ArquitecturaSistemaOperativo/SO_MaquinaExtendida.PNG)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/ArquitecturaSistemaOperativo/SO_MaquinaExtendida.PNG)

Desde el punto de vista del usuario, el sistema operativo  proporciona servicios que no están presentes en la máquina subyacente.  Estos servicios incluyen las facilidades de carga y ejecución de  programas, interacción entre el usuario y los programas, permitiendo que se ejecuten varios al mismo tiempo, gestión de los servicios y  almacenamiento de datos y programas. Como resumen, podemos decir que el sistema operativo  persigue alcanzar la mayor eficiencia posible del hardware y facilitar  el uso del mismo a los usuarios y a las aplicaciones

---

## 2. Funciones de los Sistemas Operativos

Las funciones de los sistemas operativos son múltiples y han evolucionado con los avances de la informática y el hardware. Sus objetivos principales son administrar los recursos del sistema y ofrecer una interfaz usable para que usuarios y aplicaciones puedan trabajar sin preocuparse de los detalles físicos del ordenador.

Describimos ahora las funciones más relevantes, con ejemplos concretos en **Linux (Bash, herramientas del kernel, Netplan)** y en **Windows (PowerShell, utilidades del sistema)**.

---

### 2.1 Gestión de procesos

Un **programa** es un conjunto de instrucciones almacenadas en disco; cuando se carga en memoria y se ejecuta, se convierte en uno o varios **procesos**. El sistema operativo debe crear esos procesos, asignarles CPU, planificarlos según prioridades y finalizarlos cuando terminen.

- En **Linux**, de forma estremadamente escueta (esto es todo un mundo y dedicaremos bastante tiempo a ello) los administradores usan comandos como `ps aux` para listar procesos, `top` o `htop` para monitorizarlos en tiempo real, y `kill -9 PID` o `pkill firefox` para terminar procesos bloqueados. (práctica anterior PID y PPID)
- En **Windows**, la forma gráfica clásica es el **Administrador de Tareas**, aunque pero en PowerShell se dispone de un control más técnico: `Get-Process firefox` lista procesos y `Stop-Process -Id 1234` permite terminarlos, no veremos esto hasta los terceros y cuartos bloques.

---

### 2.2 Gestión de la memoria

La gestión de memoria, suele ir asociada a la gestión de procesos. Para  ejecutar un proceso es necesario asignarle unas direcciones de memoria  exclusivas para él y cargarlo en ellas, cuando el proceso finalice su  ejecución es necesario liberar las direcciones de memoria que estaba  usando.

---

### 2.3 Gestión de ficheros

Un fichero es una abstracción para definir una colección de información no volátil. Su objetivo es proporcionar un modelo de trabajo sencillo con  la información almacenada en los dispositivos de almacenamiento. Estos  ficheros deben tener espacio asignado en los dispositivos, deben estar  protegidos entre ellos, deben organizarse según unos determinados  esquemas... todo esto es la gestión de ficheros., es decir: un fichero no es “información vaga”, sino una secuencia de bytes con metadatos, almacenada en bloques de un dispositivo y gestionada por el sistema de archivos.

En Linux, se utilizan comandos básicos (coreutils): `ls` para listar, `cp` para copiar, `rm` para borrar, y `chmod` para modificar permisos. La jerarquía siempre arranca en `/`.

En Windows, los usuarios suelen usar el Explorador de Archivos, pero con PowerShell se logra lo mismo: `Get-ChildItem C:\Windows` (equivalente a `ls`), `Copy-Item` o `Remove-Item`. La jerarquía empieza en unidades con letra (`C:\`, `D:\`).

---

### 2.4 Gestión de la red

El sistema operativo es el encargado de gestionar los distintos niveles de red, los drivers (controladores) de los dispositivos involucrados en la red, los protocolos de comunicación, las aplicaciones de red, etc.

---

### 2.5 Protección y seguridad

Mecanismos para permitir o denegar el acceso a los usuarios y a sus procesos a  determinados recursos (ficheros, dispositivos de E/S, red, etc.).

En Linux, el modelo clásico es POSIX: permisos `rwx` aplicados a propietario, grupo y otros. Solo el administrador (`root`) puede, por ejemplo, leer `/etc/shadow` (contraseñas cifradas). Además, sistemas como SELinux o AppArmor añaden políticas más finas de control.

En Windows, la seguridad se gestiona con usuarios y grupos, y cada recurso tiene ACLs (Access Control Lists) que permiten un control muy granular. Veremos que PowerShell ofrece cmdlets como `Get-Acl` para consultar permisos y `Set-Acl` para modificarlos. Además, existen mecanismos extra como BitLocker para cifrado de discos o Windows Defender para protección frente a malware.

---



## 3. Tipos de Sistemas Operativos



Existen muchas categorizaciones, pero una de las más comunes es la de los servicios que ofrece.

[![Tipos de SO](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/ArquitecturaSistemaOperativo/SO_Tipos.PNG)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/ArquitecturaSistemaOperativo/SO_Tipos.PNG)

---

### 3.1 Según el número de usuarios

#### Monousuarios

Los sistemas operativos monousuarios son aquéllos que soportan a un usuario a la vez, sin importar el número de procesadores que tenga la  computadora o el número de procesos o tareas que el usuario pueda  ejecutar en un mismo instante de tiempo. Sistemas Operativos Monousuario (muy antiguos y en desuso):

- MS-DOS (os debe sonar algo del punto anterior)
- Windows 95
- Windows 98

#### Multiusuario

Los sistemas operativos multiusuario son capaces de dar servicio a más de  un usuario a la vez, ya sea por medio de varias terminales conectadas a  la computadora o por medio de sesiones remotas en una red de  comunicaciones. No importa el número de procesadores en la máquina ni el número de procesos que cada usuario puede ejecutar simultáneamente.

Sistemas Operativos Multiusuario:

- UNIX-GNU/LinuX
- Windows NT (en adelante), después hablamos un poco sobre el

---

### 3.2 Según el número de tareas

#### Monotarea

Los sistemas monotarea son aquellos que sólo permiten una tarea a la vez  por usuario. Puede darse el caso de un sistema multiusuario y monotarea, en el cual se admiten varios usuarios al mismo tiempo pero cada uno de  ellos puede estar haciendo solo una tarea a la vez.

#### Multitarea

Un sistema operativo multitarea es aquél que le permite al usuario estar  realizando varias labores al mismo tiempo. Por ejemplo, puede estar editando el código fuente de un programa durante su depuración mientras  compila otro programa, a la vez que está recibiendo correo electrónico  en un proceso en background (segundo plano). Es común encontrar en ellos interfaces gráficas orientadas al uso de menús y el ratón, lo cual  permite un rápido intercambio entre las tareas para el usuario,  mejorando su productividad.

---

### 3.3 Sistemas Operativos Distribuidos

Un sistema distribuido se define como una colección de equipos  informáticos separados físicamente y conectados entre sí por una red de  comunicaciones distribuida; cada máquina posee sus componentes de  hardware y software de modo que el usuario percibe que existe un solo  sistema (no necesita saber qué cosas están en qué máquinas). El usuario  accede a los recursos remotos de la misma manera en que accede a  recursos locales ya que no percibe que existan varios ordenadores, sino  que solo es capaz de ver uno formado por todos los anteriores. Una ventaja fundamental de los sistemas distribuidos, es que permiten  aumentar la potencia del sistema informático, de modo que 100  ordenadores trabajando en conjunto, permiten formar un único ordenador  que sería 100 veces más potente que un ordenador convencional.

Los sistemas distribuidos son muy confiables, ya que si un componente del sistema se estropea otro componente debe de ser capaz de reemplazarlo, esto se denomina **Tolerancia a Fallos**.

El tamaño de un sistema distribuido puede ser muy variado, ya sean decenas de hosts (red de área local), centenas de hosts (red de área metropolitana), y miles o millones de hosts (Internet); esto se  denomina escalabilidad. De hecho, si un ordenador formando por un sistema distribuido se queda “corto” para las necesidades de la  empresa, basta con instalar más.

Un método similar para crear sistemas de supercomputadoras es el clustering. Un **cluster** o racimo de computadoras  consiste en un grupo de computadoras de relativo bajo costo conectadas  entre sí mediante un sistema de red de alta velocidad (gigabit de fibra óptica por lo general) y un software que realiza la distribución de la carga  de trabajo entre los equipos. Por lo general, este tipo de sistemas  cuentan con un centro de almacenamiento de datos único. Los clusters  tienen la ventaja de ser sistemas redundantes, si falla un equipo se  resiente un poco la potencia del cluster, pero los demás equipos hacen  que no se note el fallo.

Algunos sistemas operativos que permiten realizar **clustering**  son:

- DragonFly BSD

  ó

- Mosix/OpenMosix


Aunque ojo, la mayoría de estos ya están en desuso debido a la contenerización de Docker...

Un cluster que usamos habitualmente, es el que forma **Google**. Se estima que en 2010 usaba unos 450.000 ordenadores, distribuidos en  varias sedes por todo el mundo y formando clusters en cada una de dichas sedes.

A día de hoy, ¿cuál es la tendencia? Busca mas ínformación sobre la contenerización comentada.

---

## 4. Versiones en Windows

Una vez tenemos claro que tipo de sistema operativo queremos instalar, y  con qué propósito, es necesario hacer un pequeño estudio de que versión  del mismo es la que más se adecua a nuestras necesidades.

---

### 4.1 Server

En los sistemas Windows, si optamos por la familia de sistemas operativos  para servidores, contamos con una serie de versiones que nos ofrecen determinadas opciones y características. Está pensado para servicios de red y empresas, no para uso personal. Se diferencia en que se orienta a roles y características como: Active Directory (usuarios y permisos centralizados), servidor web (IIS), DHCP, DNS, Hyper-V para virtualización, etc. Puedes instalarlo con interfaz gráfica o en Server Core (modo sin GUI).

[![Windows Server](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/WindowsServer_cover.png)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/WindowsServer_cover.png) \

---

### 4.2 Windows <= 10

Los sistemas Windows para escritorio han pasado por un montón de versiones, desde Windows 3.11 a Windows 10. Estas versiones han ido apareciendo en el tiempo y su soporte por parte de Microsoft ha ido *caducando*.

Los sistemas Windows de escritorio tienen una historia larga que arranca en los años 80 y que ha pasado por varias generaciones, cada una con sus propios avances y limitaciones. Windows 3.11 (1993) fue el último de la línea “clásica” que funcionaba como una interfaz gráfica encima de MS-DOS.

Con la llegada de Windows 95 (1995) y Windows 98, Microsoft dio un salto importante: introdujo un escritorio más intuitivo, soporte para plug-and-play y una pila de red mucho más avanzada. Sin embargo, estos sistemas todavía arrastraban la herencia de DOS y no ofrecían la estabilidad que hoy se espera en entornos profesionales. En paralelo, Microsoft había creado la familia Windows NT (New Technology), diseñada desde cero como un sistema operativo de 32 bits con un kernel moderno, multitarea real y mucho más seguro. De esta rama salieron Windows 2000 y posteriormente Windows XP (2001), que fue la gran unificación: el mundo doméstico y el empresarial pasaron a compartir la misma base tecnológica (NT).

A partir de ahí, todas las versiones de escritorio —Vista, 7, 8, 8.1 y finalmente 10— se construyeron sobre NT. 



---

## 5. Distribuciones de GNU/LinuX

Los sistemas GNU/LinuX son muy variados, ya que multitud de comunidades han realizado sus propias adaptaciones y selección de aplicaciones que  desean llevar *por defecto*. Existen multitud de empresas que  utilizan GNU/LinuX, desde Red Hat (IBM), Canonical (Ubuntu), Microsoft, y otras que aunque lo utilizan no ponen su marca en ella, uno de los  ejemplos es Android y Google.

El núcleo (LinuX) + Herramientas (GNU) es lo que da lugar al sistema básico sobre el que las distribuciones y empresas trabajan. Un aspecto muy importante a destacar es que GNU/Linux se distribuye principalmente bajo la **GPL (Licencia Pública General de GNU)**, lo que garantiza la libertad de estudiar, modificar y redistribuir el software. Este modelo ha permitido su adopción masiva y su adaptación a distintos fines. Más tarde veremos cómo sucedió esto.

[<img src="https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/Gnu-and-penguin-color.png" alt="GNU/LinuX" style="zoom:100%;" />](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/Gnu-and-penguin-color.png)

---

### 5.1 Un poco de historia

Ken Thompson, Dennis Ritchie y otros investigadores de los Bell Labs (AT&T) empezaron a trabajar en un nuevo sistema operativo tras el fracaso de Multics (un proyecto demasiado ambicioso y complejo). En la década de 1970 `UNIX` era un sistema operativo no libre o privativo muy popular entre los reducidos usuarios académicos e industriales de la época.

Su éxito es atribuido a :

- La portabilidad, arquitectura simple y estabilidad
- Debido a restricciones legales de AT&T (no podía entrar directamente en el mercado de software por su monopolio en telecomunicaciones), UNIX se distribuyó a bajo coste o incluso gratis a universidades y centros de investigación. Esto provocó que Berkeley (Universidad de California) desarrollara sus propias mejoras, así nació BSD (Berkeley Software Distribution), que añadió el stack TCP/IP y otras innovaciones.
- Gran parte del éxito de UNIX se debe a que fue uno de los primeros sistemas operativos reescritos en un lenguaje de alto nivel (C), lo que lo hizo mucho más portable que otros sistemas escritos en ensamblador.
- Gracias a su distribución en universidades (ej. Berkeley, MIT), UNIX se convirtió en la cuna donde se formaron generaciones de programadores e investigadores que luego impulsaron proyectos libres (GNU, Linux, BSD).

---

### 5.2 Richard Stallman

Mientras tanto Stallman venía de una tradición de programadores completamente distinta en los laboratorios del MIT.

[<img src="https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/stallman.jpg" alt="Richard Stallman" style="zoom:50%;" />](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/stallman.jpg) 

Stallman formaba parte del *Laboratorio de Inteligencia Artificial del MIT*, donde la norma era compartir código libremente, corregirlo y mejorarlo colectivamente. La transición al software privativo, con restricciones legales y técnicas (como el uso de contraseñas en sistemas antes abiertos), fue para él una **ruptura cultural y ética**. Hacia principios de la década de 1980 la comunidad *hacker* del MIT se desmoronaba junto con sus sistemas.

Habiéndose acostrumbrado a modificar y compartir tales programas en extinción; Stallman asegura que el desarrollo de un sistema operativo libre moderno y portátil (y con éste el lanzamiento del  movimiento del software libre) fue una reacción contra lo que de otra  manera le parecía un futuro desagradable rodeado de software privativo.

En septiembre de 1983 anunció públicamente el inicio del proyecto **GNU** (*GNU’s Not Unix*), cuyo objetivo era crear un sistema operativo completamente libre, similar a UNIX pero sin restricciones de copyright que limitaran su modificación y distribución. Dos años después fundó la **Free Software Foundation (FSF)**, que proporcionó la infraestructura organizativa y legal para impulsar el software libre. Aquí también se redactaron licencias clave, como la **GPL (GNU General Public License)**, creada por Richard Stallman y la Free Software Foundation en 1989, que garantizaba la libertad de uso, modificación y redistribución del software.

Se desarrollaron herramientas esenciales que hoy en día siguen siendo pilares del software libre:

- Bash (Bourne Again Shell)
- Bibliotecas C (glibc)
- Utilidades del sistema (*coreutils*)

La pieza que faltaba: el kernel: aunque GNU logró casi todo el ecosistema de herramientas, le faltaba un núcleo libre. El intento inicial, GNU Hurd, no alcanzó la madurez en ese momento. Esta ausencia abrió el camino a la unión con el núcleo Linux creado por Linus Torvalds en 1991, lo que permitió el nacimiento de los sistemas GNU/Linux modernos.

---

### 5.3 Linus Torvalds

Armado con las herramientas de GNU, en 1991 Linus Torvalds empezó a escribir  el núcleo Linux inspirado en el libro de Minix de Andrew Tanenbaum (otro de los grandes).

[<img src="https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/Linus-Torvalds.jpg" alt="Linus Torvalds" style="zoom:80%;" />](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/Linus-Torvalds.jpg) 

En sus primeros anuncios públicos Torvalds le atribuía su  acción a la frustración de no poder usar Minix comercialmente, y a la  ausencia de núcleos libres tipo Unix como GNU Hurd o el de BSD. A pesar de sus desacuerdos suscitados a raíz de la publicación de Linux, tanto  Torvalds como Tanenbaum pronosticaban que el superior núcleo de GNU  eventualmente dejaría obsoletos a Linux y Minix.

En 1992 Torvalds decidió cambiar la licencia no comercial  de Linux a la GPL. Rápidamente, múltiples programadores se unieron en el desarrollo, colaborando a través de Internet y consiguiendo que  paulatinamente Linux fuera más serio, potente y compatible con UNIX.

Linux fue combinado con el resto del sistema GNU,  resultando en un sistema operativo libre y completamente funcional que  sigue usándose al día de hoy y en completa expansión. La combinación es conocida como "GNU/Linux" o como una "distribución Linux" y existen diversas variantes.

- **Slackware (1993)**: una de las primeras distros ampliamente usadas.
- **Debian (1993)**: pionera en organización comunitaria y en el sistema de paquetes `.deb`.
- **Red Hat (1994)**: primera gran distribución comercial, enfocada en empresas.
- Estas distribuciones empaquetaban:
  - Kernel Linux
  - Herramientas GNU (bash, gcc, coreutils, glibc)
  - Instaladores, configuraciones, y software adicional

A lo largo del módulo, veremos muchas veces `GNU/LinuX` y `LinuX` solo, pido disculpas a los puristas que puedan leer esta documentación. La nomenclatura `correcta` es **GNU/LinuX**.

------

### 5.4 Distribuciones y familias

Cuando una distribución se basa en una anterior, lo que normalmente `adopta` es la manera de empaquetar y distribuir las aplicaciones que hace disponibles para los usuarios. Por ejemplo, las basadas en Debian, siguen utilizando `.deb` como paquetes de instalación, así como repositorios que disponen de esos debs de una determinada estructura.

[<img src="https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/debian_ubuntu.jpg" alt="Debian Ubuntu" style="zoom:50%;" />](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/debian_ubuntu.jpg) 

Cuando hablamos de distribuciones GNU/Linux famosas como **Debian, Ubuntu, Fedora, Red Hat, openSUSE, Arch Linux o Alpine**, en realidad estamos viendo distintas formas de empaquetar y mantener el mismo núcleo Linux con herramientas GNU y software adicional. Cada una de estas distribuciones tiene un propósito y una filosofía distinta. Por ejemplo, Debian es reconocida por su estabilidad y por ser la base de otras muchas distribuciones, mientras que Ubuntu busca un equilibrio entre facilidad de uso y soporte comercial. Fedora se centra en ser vanguardista y probar tecnologías nuevas antes de que lleguen a Red Hat Enterprise Linux, que es la opción empresarial con soporte a largo plazo. openSUSE, por su parte, destaca por sus herramientas de administración (como YaST) y por ofrecer tanto una versión estable (Leap) como una rolling release (Tumbleweed). Arch Linux sigue la filosofía KISS (Keep It Simple, Stupid), ofreciendo al usuario control total con un sistema rolling release muy personalizable, y Alpine Linux se ha hecho popular en contenedores Docker por ser extremadamente ligera y segura al basarse en musl libc y BusyBox en lugar de glibc y coreutils.

A nivel técnico, lo que diferencia a estas familias suele ser el sistema de **gestión de paquetes y repositorios** (deb/apt en Debian/Ubuntu, rpm/dnf en Fedora/Red Hat, pacman en Arch, zypper en openSUSE), el ciclo de actualizaciones (fijo vs. rolling release) y la orientación del proyecto (comunidad, empresa, servidores, escritorio, contenedores, etc.).

---

### 5.5 No todo es GNU/Linux

Pero no todo lo que viene de UNIX hoy en día lleva kernel Linux. Existen sistemas operativos **Unix-like** que siguen en uso y que derivan directamente de la tradición BSD, no de Linux. Los más conocidos son:

- **FreeBSD**: muy usado en servidores de alto rendimiento, almacenamiento en red y sistemas embebidos. De hecho, Netflix y WhatsApp utilizan FreeBSD en sus infraestructuras.
- **OpenBSD**: famoso por su enfoque en seguridad y criptografía. De aquí salen proyectos como **OpenSSH**, que hoy se usa en prácticamente todos los sistemas Linux y Unix.
- **NetBSD**: conocido por su portabilidad, puede ejecutarse en arquitecturas de hardware muy diversas, desde PCs modernos hasta consolas antiguas o sistemas embebidos.
- **DragonFly BSD**: un descendiente más reciente, centrado en rendimiento y escalabilidad en sistemas multiprocesador.

El mundo de las distribuciones es muy complejo, y toca  estar al dia de los movimientos de las comunidades y empresas que  soportan estas distribuciones. Aqui adjunto un enlace a las distribuciones de GNU/LinuX más famosas:

[Distribuciones](https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg)

---

### 5.6 Distribuciones Famosas

#### Debian

[![Debian](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/debian.jpeg)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/debian.jpeg) \

[Debian](https://www.debian.org/intro/about#what)

#### Ubuntu

[<img src="https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/ubuntu-logo.png" alt="Ubuntu" style="zoom:50%;" />](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/ubuntu-logo.png) \

[Ubuntu](https://www.ubuntu.com/)

#### Fedora

[![Fedora](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/fedora.png)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/fedora.png) \

[Fedora](https://getfedora.org/es/)

#### RedHat

[![RedHat](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/redhat.svg.png)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/redhat.svg.png) \

[Red Hat](https://www.redhat.com/es)

#### OpenSuse

[![OpenSuse](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/opensuse.png)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/opensuse.png) 

[OpenSuse](https://www.opensuse.org/)

#### Archlinux

[![ArchLinuX](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/archlinux.png)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/archlinux.png) \

[ArchLinux](https://www.archlinux.org/)

#### Alpine

[![Alpine](https://github.com/aberlanas/ASIR-ISO/raw/master/UD01_IntroduccionSistemasOperativos/Versiones/alpine.png)](https://github.com/aberlanas/ASIR-ISO/blob/master/UD01_IntroduccionSistemasOperativos/Versiones/alpine.png) \

[Alpine](https://alpinelinux.org/)