# 4. Teoría — Hardware y Software básico de un ordenador.

## ¿Qué es la RAM?

La RAM es la memoria principal del sistema. Se organiza en direcciones lineales, <u>cada dirección contiene 1 byte</u>. La CPU puede <u>leer o escribir</u> en la RAM mediante el bus de direcciones (dice dónde) y el bus de datos (dice qué valor).

## 1. ¿Qué es la CPU?

La CPU (Unidad Central de Procesamiento) es el cerebro del ordenador. Se encarga de ejecutar instrucciones de los programas y procesa datos que se encuentran en la memoria o que recibe de dispositivos de entrada. Está formada por varias subunidades internas, como la unidad aritmético-lógica (ALU) y la unidad de control. Los registros son pequeñas áreas de memoria dentro de la CPU que almacenan temporalmente datos o direcciones. Son mucho más rápidos que la RAM y cada registro puede almacenar una cantidad fija de bits, según la arquitectura (8, 16, 32 o 64 bits). 


La unidad aritmético-lógica (ALU) es la parte de la CPU que se encarga de realizar todas las operaciones matemáticas y lógicas. Por ejemplo, suma, resta, multiplicación, división, así como operaciones lógicas como AND, OR, XOR o comparaciones entre números. Cada vez que ejecutamos una instrucción como ADD AX, BX, la ALU calcula el resultado de la operación.

Por otro lado, la unidad de control (CU) coordina todo el funcionamiento de la CPU. Su función principal es decodificar las instrucciones, decidir qué señales enviar a la ALU, a los registros y a los buses de memoria, y controlar el flujo de datos dentro de la CPU.  Gracias a la unidad de control, la CPU sabe qué operación ejecutar, qué registros usar y cuándo leer o escribir datos en la memoria. La arquitectura que pondremos de ejempo es esta

| Componente                         | Función                                                      | Ejemplo                                                      |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Registros**                      | Pequeñas memorias internas, muy rápidas, que guardan datos temporales (16, 32 o 64 bits según la arquitectura). | `MOV AX, 5` → guarda el valor 5 en AX                        |
| **ALU (Unidad Aritmético-Lógica)** | Realiza operaciones matemáticas y lógicas.                   | `ADD AX, BX` suma AX + BX                                    |
| **CU (Unidad de Control)**         | Decide qué debe hacer la CPU en cada ciclo de reloj: <br/>\- Busca la instrucción en memoria  <br/>\- La decodifica <br/>\- Genera señales de control para la ALU, registros y buses <br/>\- Coordina lectura/escritura en memoria <br/>\- Cambia el flujo del programa (saltos, interrupciones) | `MOV AX, [1234h]` : la CU ordena leer de memoria y guardar en AX |



### 1.1 Ejemplo de código ya cargado en memoria.

En la RAM no se guarda la instrucción como texto, sino en binario (código máquina). Este código máquina se ha cargado gracias a algun programa (como ensamblador), que ha traducido previamente, al compilar, las intrucciones del lenguaje. El compilador o ensamblador traduce  la instrucción del codigo por ejemplo: MOV AX, [1234h] a bytes, por ejemplo:

```bash
A1 34 12
```

- `A1h` = código de operación (opcode) para `MOV AX`
- `34 12h` = el desplazamiento también llamado offset

Posteriormente las isntrucciones se dejan en la memoria RAM, por ejemplo, en las siguientes direcciones de memoria (cada dirección ocupa 1 byte)

```makefile
Dirección 20100h: A1h
Dirección 20101h: 34h
Dirección 20102h: 12h
```



### 1.2. ¿Qué hace la Unidad de Control?

La CU entra en acción en el ciclo de instrucción (fetch-decode-execute):

#### a) Fetch (traer la instrucción)

La CU forma la dirección física  en donde e encontrará el código. Va a la RAM y lee el primer byte (`A1h`, que es el código que debe ejecutar) (Recordamos que en la RAM se guardas bytes).

1. Sabe que este es el opcode, así que consulta su “tabla interna de microcódigo” para ver qué significa.
2. Ve que debe leer dos bytes más.
3. Incrementa `IP` (un registro ya nombrado, más tarde entenderemos qué significa) para seguir leyendo: trae esos dos bytes`34h 12h`.

Ahora la CU tiene la instrucción completa en un registro interno llamado Instruction Register (IR).

#### b) Decode (decodificar)

Recordemos que la instrucción era: `MOV AX, [1234h]`. La CU analiza `A1h`, corresponde a `MOV AX` e interpreta qué debe hacer. Por tanto, la CU convierte la instrucción en señales de control para los demás bloques de la CPU.

#### c) Execute (ejecutar)

1. La CU envía la orden a la Unidad de Dirección: Calcula la dirección física
2. La CU da la orden al bus de datos: Traer 16 bits (dos bytes) de esa dirección de memoria, es decir, pasando por la direccion de memoria correspondiente (1 bytes + la siguiente, 1byte)
   
4. La CU activa la señal para que esos 16 bits se carguen en el registro `AX`.



### 1.3 ¿Cuando participa realmente la ALU?

En el ejemplo anteriores, la ALU no participa en ninguna de las fases, porque lo único que ocurre es mover datos de memoria a un registro. Eso lo resuelven la CU, los buses y la unidad de direccionamiento. Pero cuando la instrucción implica una operación aritmética (como la siguiente) o lógica incluso, entonces sí la CU tiene que “invocar” a la ALU.

```bash
ADD AX, BX
```

#### a) Fetch

La CU trae de memoria el opcode correspondiente a ADD (en este caso no sabemos cuál es paro da igual). Lo guarda en el registro Instruction Register (IR).

#### b) Decode

La CU reconoce que es ADD AX, BX y Ttaduce esto en microórdenes:

1. Cargar el contenido de AX en una entrada de la ALU.
2. Cargar el contenido de BX en la otra entrada de la ALU.
3. Configurar la ALU en modo “suma”.

#### c) Execute

La ALU realiza la suma AX + BX. El resultado se coloca en AX y la ALU actualiza las banderas (ZF, CF, OF, etc, que son otros registros) según el resultado de la operación. Estas banderas no son más que registros que obtienen valores según el resultado de la operación realizada, por ejemplo:

1. Se activa (ZF=1) cuando el resultado de una operación es cero.

2. Si el resultado no es cero: ZF=0.

Aquí la CU no hace la operación matemática, solo envía las señales: “ALU, suma estos dos valores y guarda el resultado en AX”.

---



## 2. La arquitectura de von Neumann en el diseño de un ordenador

La arquitectura de von Neumann fue propuesta en 1945 por el matemático John von Neumann (junto con otros como Mauchly y Eckert, quienes trabajaron en la ENIAC). Su idea básica fue unificar memoria y programa. Tiene mucha relación con lo ya explicado. En máquinas anteriores (como ENIAC), los programas se cableaban físicamente. Von Neumann propuso almacenar instrucciones y datos en la misma memoria, de forma que el computador pudiera modificarse simplemente cargando otro programa.

### Componentes básicos

La arquitectura clásica se compone de 5 bloques fundamentales:
1. **Unidad de procesamiento central (CPU)**
   - Unidad de control (CU): interpreta las instrucciones y genera señales para coordinar todo el hardware.
   - ALU (Arithmetic Logic Unit): ejecuta operaciones aritméticas (suma, resta, AND, OR, desplazamientos…).
   - Registros: pequeñas memorias internas muy rápidas que almacenan datos temporales, direcciones, contadores.
   - Contador de programa (PC o IP): apunta siempre a la próxima instrucción.
2. **Memoria principal (RAM)**
   - Contiene instrucciones y datos en la misma estructura lineal de direcciones.
   - Cada dirección apunta a una celda de memoria (generalmente un byte).
   - El programa y los datos están mezclados, diferenciados solo por cómo los usa la CPU.
3. **Dispositivos de entrada**
   - Permiten cargar datos en la computadora (teclado, lector de tarjetas perforadas en esa época).
4. **Dispositivos de salida**
   - Permiten ver los resultados (impresora, pantalla, etc.).
5. **Buses de comunicación**
   - Bus de direcciones: la CPU indica en qué celda de memoria quiere leer/escribir.
   - Bus de datos: transporta la información leída o escrita.
   - Bus de control: señales de sincronización (lectura/escritura, interrupciones, etc.).

### Ciclo básico (ciclo de instrucción)

El “latido” de un computador von Neumann es el ciclo fetch–decode–execute (os debe sonar de lo explicado en el punto anterior):

1. **Fetch (captura):**
   - El PC ó IP (Instruction Pointer en x86) da la dirección de la próxima instrucción.
   - La CPU la solicita a memoria a través del bus de direcciones. El contenido de esa dirección (un código máquina) llega por el bus de datos a la CPU.
2. **Decode (decodificación):**
   - La unidad de control interpreta ese código binario y decide qué operación ejecutar y qué recursos activar (ALU, registros, acceso a memoria).
3. **Execute (ejecución):**
   - Se realiza la operación: suma, movimiento de datos, salto, etc. Si el resultado debe almacenarse en memoria o un registro, se hace ahora.
4. **Update (actualización):**
   - Se incrementa el PC (IP en x86) para apuntar a la siguiente instrucción. El ciclo vuelve al paso 1.

Este proceso ocurre miles de veces por segundo en un 8086 y millones/miles de millones en procesadores modernos.

---





## 3. Núcleos y threads (hilos)

### 3.1 CPU

Una CPU lo único que sabe hacer es ejecutar instrucciones: sumar, restar, mover datos, saltar a otra parte del programa…, un programa normal está compuesto por miles o millones de estas instrucciones que se ejecutan una tras otra. 

1. Un programa es un conjunto finito y ordenado de instrucciones codificadas, escritas en un lenguaje de programación y almacenadas en un archivo ejecutable o script.

   Ese archivo define qué hacer, pero no lo está haciendo hasta que se carga en memoria. Contiene:

   - Código: secuencia de instrucciones máquina.

   - Datos estáticos: constantes, literales, recursos.

   - Estructuras de estado inicial: tablas de símbolos, direcciones de memoria preasignadas, etc

      Cuando lo cargas y el sistema operativo lo arranca, se convierte en un proceso.

2. Un proceso es una instancia en ejecución de un programa, gestionada por el sistema operativo. Se le asignan recursos: espacio de direcciones en memoria, descriptores de archivos, registros de CPU, hilos de ejecución. Mantiene un contexto de ejecución: Contador de programa (PC), Instrunction pointer (visto antes y tenéis que saber qué es), registros de CPU, pila (stack) e información de planificación (prioridad, estado de bloqueo/ejecución). Aquí ya adquiere un contexto de ejecución (memoria asignada, hilos, registros inicializados…). 

3. Un demonio es un tipo especial de proceso en sistemas tipo Unix/Linux que: 

   Se ejecuta en segundo plano y no está asociado a un terminal ni a la interacción directa del usuario. Normalmente se inicia al arrancar el sistema y permanece activo para proporcionar servicios al sistema o a otros procesos. Uno de los más comunes que utilizaremos será cron. cron = “reloj despertador” que ejecuta tareas a horas programadas.

### 3.2 Flujo de ejecución

Un flujo de ejecución es simplemente una secuencia de instrucciones que se ejecutan una detrás de otra. Si tuvieras una CPU muy simple, solo podrías ejecutar un flujo de ejecución a la vez: empieza en la instrucción 1, luego la 2, la 3… y así hasta terminar. 

### 3.3 Core

Un núcleo de CPU es una unidad de procesamiento completa dentro de un chip. Lo puedes imaginar como un procesador independiente que forma parte de un procesador más grande (multi-core).

Cada núcleo puede ejecutar su propio flujo de instrucciones (hilo, ver siguiente definición) de manera independiente, porque tiene sus propios componentes internos

- Tiene su propia ALU (suma/resta), FPU (coma flotante), CU (Control Unit) pila de ejecución.
- Si tienes 1 núcleo, solo puede ejecutar un hilo a la vez. Si tienes 4 núcleos, puede ejecutar 4 hilos a la vez de verdad, porque son 4 bloques físicos de ejecución.

Cada núcleo de CPU no solo tiene sus unidades de cálculo, también cuenta con memoria caché, para reducir la latencia al acceder a datos e instrucciones y no tener que pasar por la ram:

- **Caché L1**: La más pequeña  y la más rápida. Se divide en dos: *L1 Data Cache* (para datos) y *L1 Instruction Cache* (para instrucciones). Está dentro del núcleo.

- **Caché L2**: Más grande y un poco más lenta que L1. También suele ser privada de cada núcleo.

- **Caché L3**: Es compartida entre todos los núcleos de un mismo procesador. Sirve de “almacén común” para coordinar la información entre núcleos.

### 3.4 Thread. Hilo

Uçn hilo es un flujo de ejecución con su propio contexto:

- Tiene su propio contador de programa (sabe en qué instrucción va). El contador de programa es un registro especial de la CPU que contiene la dirección de memoria de la siguiente instrucción que se debe ejecutar, además, tiene su propio conjunto de registros  (los registros físicos están en el núcleo del procesador)

- También, puede avanzar de manera independiente respecto a otros hilos. Es importante recalcar que los hilos viven dentro de un proceso. Comparten la misma memoria y recursos del proceso padre, como: variables globales, archivos abiertos, etc. Además, los hilos posee distintos estados de ejecución: listo, en espera, ejecutando, bloqueado, etc. Como ya hemos dicho, cada hilo tiene su propio contador de programa y pila, así que pueden ejecutar partes diferentes del código al mismo tiempo. Como comparten memoria, deben usar mecanismos de sincronización (locks, semáforos, colas seguras, lo vemos en el ejemplo de python) 


<u>Eso significa que dentro de un mismo programa puedes tener varios hilos que hacen cosas distintas "en paralelo".</u>

### 3.5 HyperThreading / SMT

Los ingenieros se dieron cuenta de que un núcleo muchas veces está "vago" esperando datos de la RAM o de un disco. Para no perder tiempo, diseñaron un mecanismo donde un núcleo puede mantener dos contextos de hilos (dos contadores de programa, dos juegos de registros) y alternar instrucciones de ambos. Así, un único núcleo “finge” ser dos hilos lógicos y para el sistema operativo, parece que hay 2 procesadores. En realidad, los dos comparten el mismo hardware y compiten por recurso

Distinguimos pues, dos tipos de núcleos:

- **Núcleo físico**: lo que acabamos de describir. Es hardware real, con todos esos componentes.
- **Núcleo lógico** (SMT / HyperThreading): un núcleo físico que mantiene dos contextos de registros y PC. Permite ejecutar *dos hilos de software* como si fueran dos CPUs, compartiendo las mismas ALU/FPU.

Un núcleo lógico no duplica la ALU, solo aprovecha mejor los tiempos muertos del núcleo físico.

### 3.6 ¿Qué hace el programa Firefox?

Cuando ejecutas un programa como Firefox, no se lanza un único proceso simple, sino varios procesos diferentes. Hay un proceso principal (PPID), que controla la interfaz y coordina el resto (PID), y después otros procesos auxiliares: cada pestaña suele tener su propio proceso de contenido, existe un proceso para la GPU, otro para plugins, y algunos más para aislamiento y seguridad.

Dentro de cada uno de esos procesos, además, no corre un único hilo: se crean múltiples hilos internos que se encargan de tareas concretas. Por ejemplo, unos hilos gestionan la red, otros se ocupan de renderizar páginas, otros manejan la ejecución de JavaScript, y otros procesan audio o vídeo. Todo esto ocurre de forma automática, aunque el usuario no lo vea. Para comprobar que dicha información no es mentira, escribe en el navegador:`about:processes`. Fíjate en un proceso que te llame la atención y quédate con el PID de ese proceso (el numerito que aparece al lado del mismo). Posteriormente, a partir de ese número (llamado PID), ejecuta;

`ps -L -p <PID> -o pid,tid,psr,comm` 

Busca información sobre lo anterior. ¿Cuantos hilos corre este proceso? Prueba a matar el proceso que maneja una ventana con:

`kill <PID>`

¿Qué es lo que sucede? Esto se verá en la práctica

