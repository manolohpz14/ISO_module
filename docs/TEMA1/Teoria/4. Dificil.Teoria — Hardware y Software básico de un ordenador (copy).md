# 4. Teor√≠a ‚Äî Hardware y Software b√°sico de un ordenador.

## 1. ¬øQu√© es la CPU?

La CPU (Unidad Central de Procesamiento) es el cerebro del ordenador. Se encarga de ejecutar instrucciones de los programas y procesa datos que se encuentran en la memoria o que recibe de dispositivos de entrada. Est√° formada por varias subunidades internas, como la unidad aritm√©tico-l√≥gica (ALU) y la unidad de control.

Los registros son peque√±as √°reas de memoria dentro de la CPU que almacenan temporalmente datos o direcciones. Son mucho m√°s r√°pidos que la RAM y cada registro puede almacenar una cantidad fija de bits, seg√∫n la arquitectura (8, 16, 32 o 64 bits). 


La unidad aritm√©tico-l√≥gica (ALU) es la parte de la CPU que se encarga de realizar todas las operaciones matem√°ticas y l√≥gicas. Por ejemplo, suma, resta, multiplicaci√≥n, divisi√≥n, as√≠ como operaciones l√≥gicas como AND, OR, XOR o comparaciones entre n√∫meros. Cada vez que ejecutamos una instrucci√≥n como ADD AX, BX, la ALU calcula el resultado de la operaci√≥n.

Por otro lado, la unidad de control (CU) coordina todo el funcionamiento de la CPU. Su funci√≥n principal es decodificar las instrucciones, decidir qu√© se√±ales enviar a la ALU, a los registros y a los buses de memoria, y controlar el flujo de datos dentro de la CPU.  Gracias a la unidad de control, la CPU sabe qu√© operaci√≥n ejecutar, qu√© registros usar y cu√°ndo leer o escribir datos en la memoria. La arquitectura que pondremos de ejempo es esta



| Componente                         | Funci√≥n                                                      | Ejemplo                                                      |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Registros**                      | Peque√±as memorias internas, muy r√°pidas, que guardan datos temporales (16, 32 o 64 bits seg√∫n la arquitectura). | `MOV AX, 5` ‚Üí guarda el valor 5 en AX                        |
| **ALU (Unidad Aritm√©tico-L√≥gica)** | Realiza operaciones matem√°ticas y l√≥gicas.                   | `ADD AX, BX` suma AX + BX                                    |
| **CU (Unidad de Control)**         | Decide qu√© debe hacer la CPU en cada ciclo de reloj: <br/>\- Busca la instrucci√≥n en memoria (CS:IP) <br/>\- La decodifica <br/>\- Genera se√±ales de control para la ALU, registros y buses <br/>\- Coordina lectura/escritura en memoria <br/>\- Cambia el flujo del programa (saltos, interrupciones) | `MOV AX, [1234h]` ‚Üí la CU ordena leer de memoria y guardar en AX |

---

### 1.1 Ejemplo de c√≥digo ya cargado en memoria.

En la RAM no se guarda la instrucci√≥n como texto, sino en **binario (c√≥digo m√°quina)**. Este c√≥digo m√°quina se ha cargado gracias a algun programa (como ensamblador), que ha traducido previamente, al compilar, las intrucciones del lenguaje

- El compilador o ensamblador traduce  la instrucci√≥n del codigo por ejemplo:`MOV AX, [1234h]` a bytes, por ejemplo:

```
A1 34 12
```

- `A1h` = c√≥digo de operaci√≥n (opcode) para `MOV AX, [imm16]`.
- `34 12h` = el desplazamiento (offset = 1234h).

As√≠ que en la memoria RAM, en la posici√≥n de c√≥digo encontramos esos bytes: encontramos esos bytes (las direcciones donde se encontrar√° el c√≥digo est√° inventadas ahora mismo, pero despu√©s lo entenderemos mejor):

```
Direcci√≥n 20100h: A1h
Direcci√≥n 20101h: 34h
Direcci√≥n 20102h: 12h
```



### 1. 2. ¬øQu√© hace la Unidad de Control?

La **CU** entra en acci√≥n en el **ciclo de instrucci√≥n (fetch-decode-execute)**:

#### Fetch (traer la instrucci√≥n)

La CU forma la direcci√≥n f√≠sica  en donde e encontrar√° el c√≥digo. Va a la RAM y lee el primer byte (`A1h`).

1. Sabe que este es el opcode, as√≠ que consulta su ‚Äútabla interna de microc√≥digo‚Äù para ver qu√© significa.
2. Ve que debe leer dos bytes m√°s (el offset).
3. Incrementa `IP` (un registro ya nombrado, m√°s tarde entenderemos qu√© significa) para seguir leyendo ‚Üí trae `34h 12h`.

Ahora la CU tiene la instrucci√≥n completa en un registro interno llamado Instruction Register (IR).

#### b) Decode (decodificar)

Recordemos que la instrucci√≥n era: `MOV AX, [1234h].` La CU analiza `A1h` ‚Üí corresponde a `MOV AX, [imm16]` e interpreta que debe:

- Usar el valor inmediato `1234h` como offset.

- Combinarlo con `DS` para formar una direcci√≥n f√≠sica, que se calcula como: 

$$
\text{Direcci√≥n f√≠sica} = (\text{Segmento} \times 16) + \text{Offset}
$$

- Leer el valor de esa posici√≥n de memoria calculada en los dos pasos anteriores y copiaa ese valor en `AX`.

Por tanto; La CU convierte la instrucci√≥n en **se√±ales de control** para los dem√°s bloques de la CPU.



#### c) Execute (ejecutar)

1. La CU env√≠a la orden a la Unidad de Direcci√≥n:
   - Calcula la direcci√≥n f√≠sica = `DS √ó 16 + 1234h`.
   - Accede a la RAM.
2. La CU da la orden al bus de datos:
   - Traer 16 bits (dos bytes) de esa direcci√≥n de memoria.
3. Esos 16 bits se almacenan temporalmente en un buffer interno (a veces un latch en el bus).
4. La CU activa la se√±al para que esos 16 bits se carguen en el registro `AX`.



### 1.3 ¬øCuando participa realmente la ALU?

En el ejemplo anteriores, la ALU no participa en ninguna de las fases. porque lo √∫nico que ocurre es mover datos de memoria a un registro. Eso lo resuelven la CU, los buses y la unidad de direccionamiento. Pero cuando la instrucci√≥n implica una operaci√≥n aritm√©tica o l√≥gica, entonces s√≠ la CU tiene que ‚Äúinvocar‚Äù a la ALU.

```
ADD AX, BX
```

#### a) Fetch

La CU trae de memoria el opcode correspondiente a `ADD`. Lo guarda en el registro Instruction Register (IR).

#### b) Decode

La CU reconoce que es `ADD AX, BX` y Ttaduce esto en micro√≥rdenes:

1. Cargar el contenido de `AX` en una entrada de la ALU.
2. Cargar el contenido de `BX` en la otra entrada de la ALU.
3. Configurar la ALU en modo ‚Äúsuma‚Äù.

#### c) Execute

La ALU realiza la suma `AX + BX`. El resultado se coloca en `AX` y la ALU actualiza las banderas (`ZF`, `CF`, `OF`, etc.) seg√∫n el resultado. Estan banderas no son m√°s que registros que obtienen valores seg√∫n el resultado de la operaci√≥n realizada, por ejemplo:

1. Se activa (`ZF=1`) cuando el resultado de una operaci√≥n es cero.

2. Si el resultado no es cero ‚Üí `ZF=0`.

Aqu√≠ la CU no hace la operaci√≥n matem√°tica, solo env√≠a las se√±ales: ‚ÄúALU, suma estos dos valores y guarda el resultado en AX‚Äù.

---



## 2. ¬øQu√© es la RAM?

La RAM es la memoria principal del sistema. Se organiza en direcciones lineales, <u>cada direcci√≥n contiene 1 byte</u>. La CPU puede <u>leer o escribir</u> en la RAM mediante el bus de direcciones (dice d√≥nde) y el bus de datos (dice qu√© valor).

Ejemplo: 

```bash
MOV AX, [1234h]
```

La CPU coloca 1234h en el bus de direcciones. Activa una lectura de memoria. El valor que hay en RAM en esa direcci√≥n entra por el bus de datos y se guarda en AX.  Si quisieramos escribir en la RAM la instrucci√≥n se podr√≠a ejecutar al contrario:

```
MOV [1234h], AX
```

---





## 3. La arquitectura de von Neumann en el dise√±o de un ordenador

La arquitectura de von Neumann fue propuesta en 1945 por el matem√°tico John von Neumann (junto con otros como Mauchly y Eckert, quienes trabajaron en la ENIAC). Su idea b√°sica fue unificar memoria y programa.

En m√°quinas anteriores (como ENIAC), los programas se cableaban f√≠sicamente. Von Neumann propuso almacenar instrucciones y datos en la misma memoria, de forma que el computador pudiera modificarse simplemente cargando otro programa.

### Componentes b√°sicos

1. La arquitectura cl√°sica se compone de 5 bloques fundamentales:
   1. **Unidad de procesamiento central (CPU)**
      - Unidad de control (CU): interpreta las instrucciones y genera se√±ales para coordinar todo el hardware.
      - ALU (Arithmetic Logic Unit): ejecuta operaciones aritm√©ticas (suma, resta, AND, OR, desplazamientos‚Ä¶).
      - Registros: peque√±as memorias internas muy r√°pidas que almacenan datos temporales, direcciones, contadores.
      - Contador de programa (PC o IP): apunta siempre a la pr√≥xima instrucci√≥n.
   2. **Memoria principal (RAM)**
      - Contiene instrucciones y datos en la misma estructura lineal de direcciones.
      - Cada direcci√≥n apunta a una celda de memoria (generalmente un byte).
      - El programa y los datos est√°n mezclados, diferenciados solo por c√≥mo los usa la CPU.
   3. **Dispositivos de entrada**
      - Permiten cargar datos en la computadora (teclado, lector de tarjetas perforadas en esa √©poca).
   4. **Dispositivos de salida**
      - Permiten ver los resultados (impresora, pantalla, etc.).
   5. **Buses de comunicaci√≥n**
      - Bus de direcciones: la CPU indica en qu√© celda de memoria quiere leer/escribir.
      - Bus de datos: transporta la informaci√≥n le√≠da o escrita.
      - Bus de control: se√±ales de sincronizaci√≥n (lectura/escritura, interrupciones, etc.).

### Ciclo b√°sico (ciclo de instrucci√≥n)

1. El ‚Äúlatido‚Äù de un computador von Neumann es el **ciclo fetch‚Äìdecode‚Äìexecute** (os debe sonar de lo explicado en el punto anterior):

   1. **Fetch (captura):**
      - El PC (Instruction Pointer en x86) da la direcci√≥n de la pr√≥xima instrucci√≥n.
      - La CPU la solicita a memoria a trav√©s del bus de direcciones. El contenido de esa direcci√≥n (un c√≥digo m√°quina) llega por el bus de datos a la CPU.
   2. **Decode (decodificaci√≥n):**
      - La unidad de control interpreta ese c√≥digo binario y decide qu√© operaci√≥n ejecutar y qu√© recursos activar (ALU, registros, acceso a memoria).
   3. **Execute (ejecuci√≥n):**
      - Se realiza la operaci√≥n: suma, movimiento de datos, salto, etc. Si el resultado debe almacenarse en memoria o un registro, se hace ahora.
   4. **Update (actualizaci√≥n):**
      - Se incrementa el PC (IP en x86) para apuntar a la siguiente instrucci√≥n. El ciclo vuelve al paso 1.
   
   Este proceso ocurre miles de veces por segundo en un 8086 y millones/miles de millones en procesadores modernos.

---



## 4. Arquitectura 8086 de 16 bits (2 bytes)

Todo lo anterior eran ejemplos de este tipo de arquitectura. El 8086 es un procesador de 16 bits donde todos sus registros  son de 16 bits. Con 16 bits se pueden representar:
$$
2^{16} \ \text{ bytes distintos} = 65.536 \text{ direcciones en la ram } = 65.536¬†,\ bytes= 64 \text{ KB}
$$
Eso significa: cada direcci√≥n de memoria en la ram se√±ala un byte, no un bit.

Ejemplo:

- Direcci√≥n `00000h` ‚Üí primer byte de RAM.
- Direcci√≥n `00001h` ‚Üí segundo byte de RAM.
- Direcci√≥n `00002h` ‚Üí tercer byte de RAM.

Es decir, en teor√≠a, la RAM no deber√≠a tener m√°s de 64KB, porque no puedo acceder a registros de m√°s de 2 bytes. Sin embargo, en el 8086 el bus tiene 20 l√≠neas f√≠sicas de direcci√≥n (A0‚Ä¶A19). Con 20 l√≠neas se pueden generar:
$$
2^{20} = 1.048.576 \ \text{direcciones distintas} = 1 \text{ MB}
$$
Es por eso que la memoria m√°xima f√≠sica del 8086 es de 1 MB (1.048.576 bytes). Para direccionarla se necesitan 20 bits. Ahora bien, ¬øc√≥mo puedo acceder a direcciones de memoria mayores de 64kb en memoria si s√≥lo puedo guardar en registros de la CPU hasta 16 bits?

### 4.1 La soluci√≥n de Intel: segmentaci√≥n

Como los registros son de 16 bits, no alcanzan para 20 bits. Intel invent√≥ el sistema de segmento:offset.

- Segmento (16 bits): contenido en CS, DS, SS o ES.
- Offset (16 bits): valor en registros como IP, SP, BP, SI, DI o inmediato.
- Direcci√≥n f√≠sica:

$$
\text{Direcci√≥n f√≠sica} = (\text{Segmento} \times 16) + \text{Offset}
$$

El √ó16 = desplazar 4 bits a la izquierda : hace que los segmentos empiecen en m√∫ltiplos de 16. El offset puede variar hasta 64 KB. cada segmento cubre un bloque de 64 KB.



| Tipo de registro en 8086 de 16 bits | Ejemplos       | Uso principal                                                | Ejemplo pr√°ctico                                             |
| ----------------------------------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Prop√≥sito general**               | AX, BX, CX, DX | Guardar datos temporales y resultados de la ALU              | `MOV AX, 5`   `ADD AX, BX`                                   |
| **Segmento**                        | CS, DS, SS, ES | Seleccionar la base de un segmento de memoria (cada uno de 64 KB). | `MOV AX, [DS:1234h]` ‚Üí Direcci√≥n f√≠sica = `DS√ó16 + 1234h`    |
| **Puntero de instrucci√≥n**          | IP             | Indica el offset de la pr√≥xima instrucci√≥n dentro de CS. Lo vemos con mas detalle en el punto 5.1 | Si `CS=2000h` e `IP=0100h` ‚Üí Direcci√≥n f√≠sica = `2000h√ó16 + 0100h = 20100h` |
| **Registros de pila**               | SS, SP, BP     | Controlar la pila (stack). <br/>‚Ä¢ `SS` = segmento de pila <br/>‚Ä¢ `SP` = tope de la pila (crece hacia abajo) <br/>‚Ä¢ `BP` = base pointer, usado en marcos de funciones | `PUSH AX` guarda AX en `[SS:SP]` <br/>`POP BX` saca de `[SS:SP]` <br/>`MOV AX, [SS:BP-4]` accede a una variable local |

---



##  5. C√≥mo se carga y ejecuta un programa en un 8086

Cuando ejecutas un programa en un 8086, lo primero que hace el sistema operativo (en MS-DOS, por ejemplo) es copiar el ejecutable desde el disco a la RAM. Ese ejecutable tiene un tama√±o concreto, definido cuando lo compilaste: puede ser de 20 KB, 100 KB o 200 KB, pero nunca ‚Äúinfinito‚Äù. El sistema reserva exactamente la memoria necesaria para tu c√≥digo, tus datos y la pila.

Veamoslo con un ejemplo. Supongamos que tu programa mide 200 KB. El 8086 no puede acceder directamente a todo el MB de memoria con un registro de 16 bits. Para resolver esto usamos lo visto anteriormente:

$$
\text{Direcci√≥n f√≠sica} = \text{Segmento} \times 16 + \text{Offset}
$$
Como el Offset es te 16 bits, nos permite acceder a 64kb m√°s de memoria desde el segmento base. De esta manera, la memoria del programa se organiza en ‚Äúcap√≠tulos‚Äù de 64 KB que pueden solaparse. Veamos el siguiente ejemplo SIN SOLAPAMIENTOS.

- | Segmento         | Direcci√≥n base                                               | Tama√±o real                   | Explicaci√≥n clara                                            |
  | ---------------- | ------------------------------------------------------------ | ----------------------------- | ------------------------------------------------------------ |
  | **C√≥digo (CS1)** | `2000h (se puede guardar en el registro porque 2000 tiene 16 bits)` | 64 KB                         | Aqu√≠ empieza la primera parte del programa. **¬øPor qu√© no empieza en `1000h`?**  Porque normalmente los programas no arrancan ‚Äúdonde caiga‚Äù: el cargador del sistema operativo los ubica en direcciones alineadas y libres, y `2000h` es una buena frontera. Adem√°s, `1000h` podr√≠a estar ocupado por BIOS, vectores de interrupci√≥n o datos del sistema. |
  | **C√≥digo (CS2)** | `3000h`                                                      | 56 KB (de los 64 disponibles) | El c√≥digo era m√°s grande que 64 KB (el l√≠mite de un segmento), as√≠ que se parti√≥ en **otro bloque**. Se reserva todo el segmento, pero solo se usan 56 KB. El resto queda vac√≠o o sin usar. |
  | **Datos (DS)**   | `4000h`                                                      | 64 KB                         | Aqu√≠ van variables globales y datos est√°ticos. Usamos un segmento completo porque los programas suelen necesitar bastante espacio para datos, y as√≠ es m√°s f√°cil direccionarlos con `DS`. |
  | **Pila (SS)**    | `5000h`                                                      | 16 KB                         | El segmento de pila podr√≠a ser de hasta 64 KB, porque `SP` (stack pointer) puede contar de `0000h` a `FFFFh`. Pero no siempre hace falta. En este programa se reservaron 16 KB, suficiente para guardar direcciones de retorno (2 bytes por llamada), registros salvados y variables locales. Reservar 64 KB ser√≠a un desperdicio de memoria, sobre todo en PCs de 256 KB o 640 KB de RAM. |

### 5.1 Ejecuci√≥n de instrucciones

El flujo de tu programa comienza en `CS:IP`:

- `CS` marca el bloque de c√≥digo.
- `IP` se√±ala la primera instrucci√≥n dentro de ese bloque.

La CPU lee la instrucci√≥n, la ejecuta y despu√©s incrementa `IP` en tantos bytes como mida esa instrucci√≥n. Por ejemplo, si `IP=0100h` y la instrucci√≥n ocupa 3 bytes, al acabar `IP=0103h`, es decir, b√°sicamente suma 3 bytes para pasar a la siguiente instrucci√≥n.

### 5.2 La pila de ejecuci√≥n

El stack o pila es otra parte reservada en RAM. Est√° controlada por `SS:SP`.`SS` se√±ala el segmento de pila y `SP` es el puntero que va subiendo y bajando.

La pila funciona como una estructura LIFO:

- Cada `PUSH` reduce `SP` y guarda un valor en memoria.
- Cada `POP` aumenta `SP` y recupera el valor.

Esto se usa para guardar direcciones de retorno en las llamadas a funciones (`CALL` / `RET`) y tambi√©n para variables locales o registros temporales.

---



## 6 Ejemplo de estructura LIFO

- **SS = 5000h**
   ‚Äúmi pila vive en el segmento de memoria 5000h‚Äù. (¬øPor qu√© se llamaba segmento?)
- **Tama√±o que reservo para la pila = 16 KB**
   16 KB = `4000h` bytes dentro de ese segmento.
- **SP inicial = 4000h**
    significa ‚Äúla pila est√° vac√≠a y lista para empezar a llenarse hacia abajo‚Äù.

> Nota: `SP` no ‚Äútiene‚Äù que ser 4000h; lo pongo as√≠ **porque he reservado 16 KB**.

### 6.1. Estado inicial (vac√≠o)

```
SP = 4000h   ‚Üê pila vac√≠a (16 KB reservados)
```

### 6.2. Hacemos dos PUSH

```
MOV AX, 1234h
PUSH AX      ; guarda 1234h

MOV BX, 5678h
PUSH BX      ; guarda 5678h

```

### 6.3. Miramos como se guarda la informacion en cada direcci√≥n de memoria:

```
Direcci√≥n   Contenido
5000:3FFC   78h   ‚Üê byte bajo de BX
5000:3FFD   56h   ‚Üê byte alto de BX
5000:3FFE   34h   ‚Üê byte bajo de AX
5000:3FFF   12h   ‚Üê byte alto de AX
SP = 3FFCh


```

üëâObserva 3 cosas importantes:

1. **BX (5678h)** qued√≥ m√°s arriba en la pila porque fue el √∫ltimo en entrar.
2. **AX (1234h)** qued√≥ m√°s abajo, porque entr√≥ primero.
3. `SP = 3FFCh` ‚Üí apunta al inicio del √∫ltimo valor guardado (BX).

Esto refleja la regla LIFO (**Last In, First Out**): el √∫ltimo en entrar ser√° el primero en salir.

### 6.4. Hacemos un POP

Ejecutamos:

```
POP CX
```

Es la instrucci√≥n que:

1. Toma el valor que est√° arriba de la pila (16 bits = 2 bytes).
2. Lo coloca en el registro CX.
3. Ajusta `SP` subiendo 2 posiciones, dejando la pila un poco m√°s ‚Äúvac√≠a‚Äù.

4. La CPU lee los 2 bytes en `3FFCh` y `3FFDh`: `78h` (bajo), `56h` (alto) ‚Üí `CX = 5678h`. `SP` sube en 2 ‚Üí `SP = 3FFEh`.

Estado de la pila ahora:

```
Direcci√≥n   Contenido
5000:3FFE   34h   ‚Üê byte bajo de AX
5000:3FFF   12h   ‚Üê byte alto de AX
SP = 3FFEh
CX = 5678h

```



## 3. N√∫cleos y threads (hilos)

### 1. CPU

Una CPU lo √∫nico que sabe hacer es ejecutar instrucciones: sumar, restar, mover datos, saltar a otra parte del programa‚Ä¶, un programa normal est√° compuesto por miles o millones de estas instrucciones que se ejecutan una tras otra. 

1. Un programa es un conjunto finito y ordenado de instrucciones codificadas, escritas en un lenguaje de programaci√≥n y almacenadas en un archivo ejecutable o script.
   
   Ese archivo define qu√© hacer, pero no lo est√° haciendo hasta que se carga en memoria. Contiene:
   
   - C√≥digo: secuencia de instrucciones m√°quina.
   - Datos est√°ticos: constantes, literales, recursos.
   - Estructuras de estado inicial: tablas de s√≠mbolos, direcciones de memoria preasignadas, etc.

‚Äã    Cuando lo cargas y el sistema operativo lo arranca, se convierte en un proceso.

2. Un proceso es una instancia en ejecuci√≥n de un programa, gestionada por el sistema operativo.

- Se le asignan recursos: espacio de direcciones en memoria, descriptores de archivos, registros de CPU, hilos de ejecuci√≥n. Mantiene un contexto de ejecuci√≥n:

  - Contador de programa (PC) IInstruction pointer visto antes)
  - Registros de CPU
  - Pila (stack)
  - Informaci√≥n de planificaci√≥n (prioridad, estado de bloqueo/ejecuci√≥n).

  Aqu√≠ ya adquiere un contexto de ejecuci√≥n (memoria asignada, hilos, registros  inicializados‚Ä¶). 

3. Un demonio es un tipo especial de proceso en sistemas tipo Unix/Linux que: 

   Se ejecuta en segundo plano y no est√° asociado a un terminal ni a la interacci√≥n directa del usuario. Normalmente se inicia al arrancar el sistema y permanece activo para proporcionar servicios al sistema o a otros procesos. Uno de los m√°s comunes que utilizaremos ser√° cron. cron = ‚Äúreloj despertador‚Äù que ejecuta tareas a horas programadas.

### 2. Flujo de ejecuci√≥n

Un flujo de ejecuci√≥n es simplemente esa secuencia de instrucciones que se ejecutan una detr√°s de otra. Si tuvieras una CPU muy simple, solo podr√≠as ejecutar un flujo de ejecuci√≥n a la vez: empieza en la instrucci√≥n 1, luego la 2, la 3‚Ä¶ y as√≠ hasta terminar. 

### 3. Thread. Hilo

Un hilo es un flujo de ejecuci√≥n con su propio contexto:

- Tiene su propio contador de programa (sabe en qu√© instrucci√≥n va).  Registro especial de la CPU que contiene la direcci√≥n de memoria de la siguiente instrucci√≥n que se debe ejecutar, adem√°s, tiene su propio conjunto de registros  (los registros f√≠sicos est√°n en el n√∫cleo del procesador)

- Tambi√©n, puede avanzar de manera independiente respecto a otros hilos.

- Es importante recalcar que los hilos viven dentro de un proceso. Comparten la misma memoria y recursos del proceso padre, como: variables globales, archivos abiertos, etc.

  Como ya hemos dicho, cada hilo tiene su propio contador de programa y pila, as√≠ que pueden ejecutar partes diferentes del c√≥digo al mismo tiempo. Como comparten memoria, deben usar mecanismos de sincronizaci√≥n (locks, sem√°foros, colas seguras, lo vemos en el ejemplo de python) 

<u>Eso significa que dentro de un mismo programa puedes tener varios hilos que hacen cosas distintas en paralelo.</u>

### 4. Core

Un n√∫cleo de CPU es una unidad de procesamiento completa dentro de un chip.
 Lo puedes imaginar como un procesador independiente que forma parte de un procesador m√°s grande (multi-core).

Cada n√∫cleo puede ejecutar su propio flujo de instrucciones (hilo) de manera independiente, porque tiene sus propios componentes internos

- Tiene su propia ALU (suma/resta), FPU (coma flotante), CU (Control Unit) pila de ejecuci√≥n.
- Si tienes 1 n√∫cleo, solo puede ejecutar un hilo a la vez. Si tienes 4 n√∫cleos, puede ejecutar 4 hilos a la vez de verdad, porque son 4 bloques f√≠sicos de ejecuci√≥n.

Cada n√∫cleo de CPU no solo tiene sus unidades de c√°lculo, tambi√©n cuenta con memoria cach√©** para reducir la latencia al acceder a datos e instrucciones y no tener que pasar por la ram:

- **Cach√© L1**:
  
  La m√°s peque√±a (32‚Äì64 KB normalmente) y la m√°s r√°pida. Se divide en dos: *L1 Data Cache* (para datos) y *L1 Instruction Cache* (para instrucciones). Est√° dentro del n√∫cleo.
- **Cach√© L2**:
  
  M√°s grande (256 KB ‚Äì 1 MB por n√∫cleo) y un poco m√°s lenta que L1. Tambi√©n suele ser privada de cada n√∫cleo.
- **Cach√© L3**:
  
  Mucho m√°s grande (varios MB). Es compartida entre todos los n√∫cleos de un mismo procesador. Sirve de ‚Äúalmac√©n com√∫n‚Äù para coordinar la informaci√≥n entre n√∫cleos.

### 5. HyperThreading / SMT

Los ingenieros se dieron cuenta de que un n√∫cleo muchas veces est√° ocioso esperando datos de la RAM o de un disco. Para no perder tiempo, dise√±aron un mecanismo donde un n√∫cleo puede mantener dos contextos de hilos (dos contadores de programa, dos juegos de registros) y alternar instrucciones de ambos.

- As√≠, un √∫nico n√∫cleo ‚Äúfinge‚Äù ser dos hilos l√≥gicos y para el sistema operativo, parece que hay 2 procesadores.
- En realidad, los dos comparten el mismo hardware y compiten por recurso

Distinguimos pues, dos tipos de n√∫cleos:

- **N√∫cleo f√≠sico**: lo que acabamos de describir. Es hardware real, con todos esos componentes.
- N√∫cleo l√≥gico (SMT / HyperThreading): un n√∫cleo f√≠sico que mantiene dos contextos de registros y PC. Permite ejecutar *dos hilos de software* como si fueran dos CPUs, compartiendo las mismas ALU/FPU.

Un n√∫cleo l√≥gico no duplica la ALU, solo aprovecha mejor los tiempos muertos del n√∫cleo f√≠sico.



### 6. ¬øQu√© hace el programa Firefox?

Cuando ejecutas un programa como Firefox, no se lanza un √∫nico proceso simple, sino varios procesos diferentes. Hay un proceso principal (PPID), que controla la interfaz y coordina el resto (PID), y despu√©s otros procesos auxiliares: cada pesta√±a suele tener su propio proceso de contenido, existe un proceso para la GPU, otro para plugins, y algunos m√°s para aislamiento y seguridad.

Dentro de cada uno de esos procesos, adem√°s, no corre un √∫nico hilo: se crean m√∫ltiples hilos internos que se encargan de tareas concretas. Por ejemplo, unos hilos gestionan la red, otros se ocupan de renderizar p√°ginas, otros manejan la ejecuci√≥n de JavaScript, y otros procesan audio o v√≠deo. Todo esto ocurre de forma autom√°tica, aunque el usuario no lo vea.



### 7. Simulando concurrencia y paralelismo en un lenuaje de programaci√≥n. Python

En Python hay dos librer√≠as principales para trabajar con concurrencia:

- `threading`: crea hilos de software gestionados por el int√©rprete. 
- `multiprocessing`: crea procesos independientes, cada uno con su propio int√©rprete Python.

---





# Ejemplo t√©cnico en Python

```python
from multiprocessing import Pool, cpu_count
import os

def tarea(id):
    print(f"Tarea {id} ejecut√°ndose en PID {os.getpid()}")
    # Simulaci√≥n de trabajo pesado (CPU-bound)
    suma = 0
    for i in range(10**7):
        suma += i
    return f"Tarea {id} termin√≥ con suma={suma}"

if __name__ == "__main__":
    # Detectamos n¬∫ de CPUs l√≥gicas (n√∫cleos √ó hilos por n√∫cleo con SMT/HT)
    hilos_logicos = cpu_count()
    print(f"Procesadores l√≥gicos detectados: {hilos_logicos}")

    # Creamos un pool de procesos igual a los hilos l√≥gicos de 8 procesos
    with Pool(processes=hilos_logicos) as pool:
        resultados = pool.map(tarea, range(8))

    for r in resultados:
        print(r)
```

**`cpu_count()`**

Pregunta al sistema operativo cu√°ntos *procesadores l√≥gicos* hay disponibles. Si tienes 4 n√∫cleos con HyperThreading, devuelve 8.

**`Pool(processes=hilos_logicos)`**

- Crea un conjunto de procesos hijo, tendran PPID del proceso padre.
- Cada proceso es independiente, con su propio int√©rprete Python y su propio espacio de memoria.
- El sistema operativo los distribuye entre los n√∫cleos f√≠sicos y los hilos de hardware.

**`pool.map(tarea, range(8))`**

Lanza 8 tareas que se ejecutan concurrentemente. Si tienes 8 procesadores l√≥gicos, todas corren a la vez. Si tienes menos , el sistema operativo hace *scheduling* y las alterna.

Como son procesos independientes, aqu√≠ s√≠ se aprovechan los varios n√∫cleos de la CPU. Si tu CPU soporta SMT, entonces algunos procesos pueden compartir un n√∫cleo f√≠sico mediante HyperThreading. Vemos el siguiente ejemplo

```python
import threading, queue, time, random

buffer = queue.Queue(maxsize=5)

def productor():
    for i in range(20):
        item = f"item-{i}"
        buffer.put(item)  # se bloquea si est√° llena
        print(f"[{threading.get_native_id()}] Produjo: {item} (buffer={buffer.qsize()})")
        time.sleep(0.1)  # produce muy r√°pido

def consumidor():
    for i in range(20):
        item = buffer.get()  # se bloquea si est√° vac√≠a
        print(f"[{threading.get_native_id()}] Consumi√≥: {item} (buffer={buffer.qsize()})")
        time.sleep(0.5)  # consume m√°s lento

if __name__ == "__main__":
    t1 = threading.Thread(target=productor)
    t2 = threading.Thread(target=consumidor)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

```



El ejemplo anterior (`multiprocessing.Pool`) usaba procesos, cada uno con su propio espacio de memoria. Este ejemplo usa hilos, comparten memoria, y por eso necesitan sincronizaci√≥n.