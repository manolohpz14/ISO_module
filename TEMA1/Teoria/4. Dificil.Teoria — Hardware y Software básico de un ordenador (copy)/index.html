
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>4. Teor√≠a ‚Äî Hardware y Software b√°sico de un ordenador. - M√≥dulo ISO</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#4-teoria-hardware-y-software-basico-de-un-ordenador" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="M√≥dulo ISO" class="md-header__button md-logo" aria-label="M√≥dulo ISO" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            M√≥dulo ISO
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              4. Teor√≠a ‚Äî Hardware y Software b√°sico de un ordenador.
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="M√≥dulo ISO" class="md-nav__button md-logo" aria-label="M√≥dulo ISO" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    M√≥dulo ISO
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Inicio
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tema 1. Introducci√≥n a los Sistemas Operativos y Hardware
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tema 1. Introducci√≥n a los Sistemas Operativos y Hardware
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../1.%20Teoria%20de%20Markdown%20SIMPLE/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    1er Archivo Teor√≠a (Markdown)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2.%20Teor%C3%ADa%20de%20Sistemas%20Num%C3%A9ricos%20en%20Inform%C3%A1tica/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2do Archivo Teor√≠a (Sistemas Num√©ricos)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../3.%20Teoria%20de%20Almacenamiento%20de%20datos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3er Archivo Teor√≠a (Almacenamiento de datos)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../4.%20Teoria%20%E2%80%94%20Hardware%20y%20Software%20b%C3%A1sico%20de%20un%20ordenador/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    4to Archivo Teor√≠a (Hardware y Software)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../5.%20Teor%C3%ADa%20Sistemas%20Operativos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    5to Archivo Teor√≠a (Sistemas Operativos y Virtualizaci√≥n)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Practicas/1¬™Practica.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    1¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Practicas/2.%20Pr%C3%A1ctica%20%E2%80%94%20Observar%20la%20diferencia%20en%20notaci%C3%B3n%20decimal%20vs%20binaria.%20Rellena%20la%20siguiente%20tabla/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Practicas/3.%20Pr%C3%A1ctica%20%E2%80%94%20Observar%20la%20diferencia%20en%20notaci%C3%B3n%20decimal%20vs%20binaria.%20Probamos%20la%20CLI%20de%20Ubuntu/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Practicas/4.%20Pr%C3%A1ctica%20%E2%80%94%20Curiosidades%20y%20importancia%20de%20los%20sistemas%20de%20enumeraci%C3%B3n%20binario%20y%20hexadecimal%20en%20la%20informatica/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    4¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Practicas/4.2.%20Pr%C3%A1ctica%20%E2%80%94%20Comparaci%C3%B3n%20GUI%20vs%20CLI%20en%20Ubuntu%20e%20instalaci%C3%B3n%20de%20KDE%20%28copy%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    4¬™ Practica (versi√≥n 2)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Practicas/5.%20Pr%C3%A1cticaTrabajoCooperativo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    5¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tema 2. Virtualizaci√≥n e instalaciones de sistemas operativos
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tema 2. Virtualizaci√≥n e instalaciones de sistemas operativos
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA2/Teoria/1%C2%AA%20Teoria%20virtualizacion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    1er Archivo Teor√≠a (QEMU-KVM)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA2/Teoria/2%20Teor%C3%ADa%20de%20las%20instalaciones/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2do Archivo Teor√≠a (Instalaciones y Particiones)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA2/Practicas/1%C2%AA%20Pr%C3%A1ctica%20virtualizacion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    1¬™ Practica (Opcional. Virtualizacion Anidada)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA2/Practicas/2%20Pr%C3%A1ctica%20Instalaci%C3%B3n%20de%20Ubuntu%20sin%20LUKS%20%28sin%20LVM%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA2/Practicas/3%20Pr%C3%A1ctica%20Instalaci%C3%B3n%20Dual%20de%20ubuntu%20%2B%20Windows/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA2/Practicas/4%C2%AA%20Pr%C3%A1ctica%20Migraci%C3%B3n%20de%20un%20disco%20de%20120%20GB%20%28M%C3%A1s%20grande%29%20a%20otro%20de%20100%20GB%20%28M%C3%A1s%20chico%29%20usando%20GParted%20y%20el%20comando%20dd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    4¬™ Practica
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tema 3. Sistema operativo Linux-Debian
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tema 3. Sistema operativo Linux-Debian
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA3/Practicas/1¬™Practica. Administracion_de_usuarios_y_permisos_ambientada_en_attack_on_titan.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    1¬™ Practica Guiada (Administraci√≥n de permisos en directorios)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA3/Practicas/2¬™ Practica Permisos AOT.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2¬™ Practica Guiada (Administraci√≥n de permisos en binarios)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA3/Practicas/3¬™ Practica SUDOERS Y UMASK Y SKELL.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3¬™ Practica Guiada (/etc/skell, .bashrc, umask y SUDOERS)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEMA3/Practicas/4¬™ Practica APT.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    4¬™ Practica Guiada (Uso de APT avanzado)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-que-es-la-cpu" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. ¬øQu√© es la CPU?
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. ¬øQu√© es la CPU?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-ejemplo-de-codigo-ya-cargado-en-memoria" class="md-nav__link">
    <span class="md-ellipsis">
      
        1.1 Ejemplo de c√≥digo ya cargado en memoria.
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-2-que-hace-la-unidad-de-control" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 2. ¬øQu√© hace la Unidad de Control?
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. 2. ¬øQu√© hace la Unidad de Control?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fetch-traer-la-instruccion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Fetch (traer la instrucci√≥n)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-decode-decodificar" class="md-nav__link">
    <span class="md-ellipsis">
      
        b) Decode (decodificar)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-execute-ejecutar" class="md-nav__link">
    <span class="md-ellipsis">
      
        c) Execute (ejecutar)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-cuando-participa-realmente-la-alu" class="md-nav__link">
    <span class="md-ellipsis">
      
        1.3 ¬øCuando participa realmente la ALU?
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.3 ¬øCuando participa realmente la ALU?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-fetch" class="md-nav__link">
    <span class="md-ellipsis">
      
        a) Fetch
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-decode" class="md-nav__link">
    <span class="md-ellipsis">
      
        b) Decode
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-execute" class="md-nav__link">
    <span class="md-ellipsis">
      
        c) Execute
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-que-es-la-ram" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. ¬øQu√© es la RAM?
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-la-arquitectura-de-von-neumann-en-el-diseno-de-un-ordenador" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. La arquitectura de von Neumann en el dise√±o de un ordenador
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. La arquitectura de von Neumann en el dise√±o de un ordenador">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#componentes-basicos" class="md-nav__link">
    <span class="md-ellipsis">
      
        Componentes b√°sicos
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ciclo-basico-ciclo-de-instruccion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Ciclo b√°sico (ciclo de instrucci√≥n)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-arquitectura-8086-de-16-bits-2-bytes" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Arquitectura 8086 de 16 bits (2 bytes)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Arquitectura 8086 de 16 bits (2 bytes)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-la-solucion-de-intel-segmentacion" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1 La soluci√≥n de Intel: segmentaci√≥n
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-como-se-carga-y-ejecuta-un-programa-en-un-8086" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. C√≥mo se carga y ejecuta un programa en un 8086
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. C√≥mo se carga y ejecuta un programa en un 8086">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-ejecucion-de-instrucciones" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.1 Ejecuci√≥n de instrucciones
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-la-pila-de-ejecucion" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.2 La pila de ejecuci√≥n
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-ejemplo-de-estructura-lifo" class="md-nav__link">
    <span class="md-ellipsis">
      
        6 Ejemplo de estructura LIFO
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6 Ejemplo de estructura LIFO">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-estado-inicial-vacio" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.1. Estado inicial (vac√≠o)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-hacemos-dos-push" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.2. Hacemos dos PUSH
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-miramos-como-se-guarda-la-informacion-en-cada-direccion-de-memoria" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.3. Miramos como se guarda la informacion en cada direcci√≥n de memoria:
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64-hacemos-un-pop" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.4. Hacemos un POP
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-nucleos-y-threads-hilos" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. N√∫cleos y threads (hilos)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. N√∫cleos y threads (hilos)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-cpu" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. CPU
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-flujo-de-ejecucion" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Flujo de ejecuci√≥n
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-thread-hilo" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Thread. Hilo
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-core" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Core
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-hyperthreading-smt" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. HyperThreading / SMT
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-que-hace-el-programa-firefox" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. ¬øQu√© hace el programa Firefox?
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7-simulando-concurrencia-y-paralelismo-en-un-lenuaje-de-programacion-python" class="md-nav__link">
    <span class="md-ellipsis">
      
        7. Simulando concurrencia y paralelismo en un lenuaje de programaci√≥n. Python
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="4-teoria-hardware-y-software-basico-de-un-ordenador">4. Teor√≠a ‚Äî Hardware y Software b√°sico de un ordenador.</h1>
<h2 id="1-que-es-la-cpu">1. ¬øQu√© es la CPU?</h2>
<p>La CPU (Unidad Central de Procesamiento) es el cerebro del ordenador. Se encarga de ejecutar instrucciones de los programas y procesa datos que se encuentran en la memoria o que recibe de dispositivos de entrada. Est√° formada por varias subunidades internas, como la unidad aritm√©tico-l√≥gica (ALU) y la unidad de control.</p>
<p>Los registros son peque√±as √°reas de memoria dentro de la CPU que almacenan temporalmente datos o direcciones. Son mucho m√°s r√°pidos que la RAM y cada registro puede almacenar una cantidad fija de bits, seg√∫n la arquitectura (8, 16, 32 o 64 bits). </p>
<p>La unidad aritm√©tico-l√≥gica (ALU) es la parte de la CPU que se encarga de realizar todas las operaciones matem√°ticas y l√≥gicas. Por ejemplo, suma, resta, multiplicaci√≥n, divisi√≥n, as√≠ como operaciones l√≥gicas como AND, OR, XOR o comparaciones entre n√∫meros. Cada vez que ejecutamos una instrucci√≥n como ADD AX, BX, la ALU calcula el resultado de la operaci√≥n.</p>
<p>Por otro lado, la unidad de control (CU) coordina todo el funcionamiento de la CPU. Su funci√≥n principal es decodificar las instrucciones, decidir qu√© se√±ales enviar a la ALU, a los registros y a los buses de memoria, y controlar el flujo de datos dentro de la CPU.  Gracias a la unidad de control, la CPU sabe qu√© operaci√≥n ejecutar, qu√© registros usar y cu√°ndo leer o escribir datos en la memoria. La arquitectura que pondremos de ejempo es esta</p>
<table>
<thead>
<tr>
<th>Componente</th>
<th>Funci√≥n</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Registros</strong></td>
<td>Peque√±as memorias internas, muy r√°pidas, que guardan datos temporales (16, 32 o 64 bits seg√∫n la arquitectura).</td>
<td><code>MOV AX, 5</code> ‚Üí guarda el valor 5 en AX</td>
</tr>
<tr>
<td><strong>ALU (Unidad Aritm√©tico-L√≥gica)</strong></td>
<td>Realiza operaciones matem√°ticas y l√≥gicas.</td>
<td><code>ADD AX, BX</code> suma AX + BX</td>
</tr>
<tr>
<td><strong>CU (Unidad de Control)</strong></td>
<td>Decide qu√© debe hacer la CPU en cada ciclo de reloj: <br/>- Busca la instrucci√≥n en memoria (CS:IP) <br/>- La decodifica <br/>- Genera se√±ales de control para la ALU, registros y buses <br/>- Coordina lectura/escritura en memoria <br/>- Cambia el flujo del programa (saltos, interrupciones)</td>
<td><code>MOV AX, [1234h]</code> ‚Üí la CU ordena leer de memoria y guardar en AX</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="11-ejemplo-de-codigo-ya-cargado-en-memoria">1.1 Ejemplo de c√≥digo ya cargado en memoria.</h3>
<p>En la RAM no se guarda la instrucci√≥n como texto, sino en <strong>binario (c√≥digo m√°quina)</strong>. Este c√≥digo m√°quina se ha cargado gracias a algun programa (como ensamblador), que ha traducido previamente, al compilar, las intrucciones del lenguaje</p>
<ul>
<li>El compilador o ensamblador traduce  la instrucci√≥n del codigo por ejemplo:<code>MOV AX, [1234h]</code> a bytes, por ejemplo:</li>
</ul>
<div class="highlight"><pre><span></span><code>A1 34 12
</code></pre></div>
<ul>
<li><code>A1h</code> = c√≥digo de operaci√≥n (opcode) para <code>MOV AX, [imm16]</code>.</li>
<li><code>34 12h</code> = el desplazamiento (offset = 1234h).</li>
</ul>
<p>As√≠ que en la memoria RAM, en la posici√≥n de c√≥digo encontramos esos bytes: encontramos esos bytes (las direcciones donde se encontrar√° el c√≥digo est√° inventadas ahora mismo, pero despu√©s lo entenderemos mejor):</p>
<div class="highlight"><pre><span></span><code>Direcci√≥n 20100h: A1h
Direcci√≥n 20101h: 34h
Direcci√≥n 20102h: 12h
</code></pre></div>
<h3 id="1-2-que-hace-la-unidad-de-control">1. 2. ¬øQu√© hace la Unidad de Control?</h3>
<p>La <strong>CU</strong> entra en acci√≥n en el <strong>ciclo de instrucci√≥n (fetch-decode-execute)</strong>:</p>
<h4 id="fetch-traer-la-instruccion">Fetch (traer la instrucci√≥n)</h4>
<p>La CU forma la direcci√≥n f√≠sica  en donde e encontrar√° el c√≥digo. Va a la RAM y lee el primer byte (<code>A1h</code>).</p>
<ol>
<li>Sabe que este es el opcode, as√≠ que consulta su ‚Äútabla interna de microc√≥digo‚Äù para ver qu√© significa.</li>
<li>Ve que debe leer dos bytes m√°s (el offset).</li>
<li>Incrementa <code>IP</code> (un registro ya nombrado, m√°s tarde entenderemos qu√© significa) para seguir leyendo ‚Üí trae <code>34h 12h</code>.</li>
</ol>
<p>Ahora la CU tiene la instrucci√≥n completa en un registro interno llamado Instruction Register (IR).</p>
<h4 id="b-decode-decodificar">b) Decode (decodificar)</h4>
<p>Recordemos que la instrucci√≥n era: <code>MOV AX, [1234h].</code> La CU analiza <code>A1h</code> ‚Üí corresponde a <code>MOV AX, [imm16]</code> e interpreta que debe:</p>
<ul>
<li>
<p>Usar el valor inmediato <code>1234h</code> como offset.</p>
</li>
<li>
<p>Combinarlo con <code>DS</code> para formar una direcci√≥n f√≠sica, que se calcula como: </p>
</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Direcci√≥n f√≠sica} = (\text{Segmento} \times 16) + \text{Offset}
</div>
<script type="math/tex; mode=display">
\text{Direcci√≥n f√≠sica} = (\text{Segmento} \times 16) + \text{Offset}
</script>
</div>
<ul>
<li>Leer el valor de esa posici√≥n de memoria calculada en los dos pasos anteriores y copiaa ese valor en <code>AX</code>.</li>
</ul>
<p>Por tanto; La CU convierte la instrucci√≥n en <strong>se√±ales de control</strong> para los dem√°s bloques de la CPU.</p>
<h4 id="c-execute-ejecutar">c) Execute (ejecutar)</h4>
<ol>
<li>La CU env√≠a la orden a la Unidad de Direcci√≥n:</li>
<li>Calcula la direcci√≥n f√≠sica = <code>DS √ó 16 + 1234h</code>.</li>
<li>Accede a la RAM.</li>
<li>La CU da la orden al bus de datos:</li>
<li>Traer 16 bits (dos bytes) de esa direcci√≥n de memoria.</li>
<li>Esos 16 bits se almacenan temporalmente en un buffer interno (a veces un latch en el bus).</li>
<li>La CU activa la se√±al para que esos 16 bits se carguen en el registro <code>AX</code>.</li>
</ol>
<h3 id="13-cuando-participa-realmente-la-alu">1.3 ¬øCuando participa realmente la ALU?</h3>
<p>En el ejemplo anteriores, la ALU no participa en ninguna de las fases. porque lo √∫nico que ocurre es mover datos de memoria a un registro. Eso lo resuelven la CU, los buses y la unidad de direccionamiento. Pero cuando la instrucci√≥n implica una operaci√≥n aritm√©tica o l√≥gica, entonces s√≠ la CU tiene que ‚Äúinvocar‚Äù a la ALU.</p>
<div class="highlight"><pre><span></span><code>ADD AX, BX
</code></pre></div>
<h4 id="a-fetch">a) Fetch</h4>
<p>La CU trae de memoria el opcode correspondiente a <code>ADD</code>. Lo guarda en el registro Instruction Register (IR).</p>
<h4 id="b-decode">b) Decode</h4>
<p>La CU reconoce que es <code>ADD AX, BX</code> y Ttaduce esto en micro√≥rdenes:</p>
<ol>
<li>Cargar el contenido de <code>AX</code> en una entrada de la ALU.</li>
<li>Cargar el contenido de <code>BX</code> en la otra entrada de la ALU.</li>
<li>Configurar la ALU en modo ‚Äúsuma‚Äù.</li>
</ol>
<h4 id="c-execute">c) Execute</h4>
<p>La ALU realiza la suma <code>AX + BX</code>. El resultado se coloca en <code>AX</code> y la ALU actualiza las banderas (<code>ZF</code>, <code>CF</code>, <code>OF</code>, etc.) seg√∫n el resultado. Estan banderas no son m√°s que registros que obtienen valores seg√∫n el resultado de la operaci√≥n realizada, por ejemplo:</p>
<ol>
<li>
<p>Se activa (<code>ZF=1</code>) cuando el resultado de una operaci√≥n es cero.</p>
</li>
<li>
<p>Si el resultado no es cero ‚Üí <code>ZF=0</code>.</p>
</li>
</ol>
<p>Aqu√≠ la CU no hace la operaci√≥n matem√°tica, solo env√≠a las se√±ales: ‚ÄúALU, suma estos dos valores y guarda el resultado en AX‚Äù.</p>
<hr />
<h2 id="2-que-es-la-ram">2. ¬øQu√© es la RAM?</h2>
<p>La RAM es la memoria principal del sistema. Se organiza en direcciones lineales, <u>cada direcci√≥n contiene 1 byte</u>. La CPU puede <u>leer o escribir</u> en la RAM mediante el bus de direcciones (dice d√≥nde) y el bus de datos (dice qu√© valor).</p>
<p>Ejemplo: </p>
<div class="highlight"><pre><span></span><code>MOV<span class="w"> </span>AX,<span class="w"> </span><span class="o">[</span>1234h<span class="o">]</span>
</code></pre></div>
<p>La CPU coloca 1234h en el bus de direcciones. Activa una lectura de memoria. El valor que hay en RAM en esa direcci√≥n entra por el bus de datos y se guarda en AX.  Si quisieramos escribir en la RAM la instrucci√≥n se podr√≠a ejecutar al contrario:</p>
<div class="highlight"><pre><span></span><code>MOV [1234h], AX
</code></pre></div>
<hr />
<h2 id="3-la-arquitectura-de-von-neumann-en-el-diseno-de-un-ordenador">3. La arquitectura de von Neumann en el dise√±o de un ordenador</h2>
<p>La arquitectura de von Neumann fue propuesta en 1945 por el matem√°tico John von Neumann (junto con otros como Mauchly y Eckert, quienes trabajaron en la ENIAC). Su idea b√°sica fue unificar memoria y programa.</p>
<p>En m√°quinas anteriores (como ENIAC), los programas se cableaban f√≠sicamente. Von Neumann propuso almacenar instrucciones y datos en la misma memoria, de forma que el computador pudiera modificarse simplemente cargando otro programa.</p>
<h3 id="componentes-basicos">Componentes b√°sicos</h3>
<ol>
<li>La arquitectura cl√°sica se compone de 5 bloques fundamentales:</li>
<li><strong>Unidad de procesamiento central (CPU)</strong><ul>
<li>Unidad de control (CU): interpreta las instrucciones y genera se√±ales para coordinar todo el hardware.</li>
<li>ALU (Arithmetic Logic Unit): ejecuta operaciones aritm√©ticas (suma, resta, AND, OR, desplazamientos‚Ä¶).</li>
<li>Registros: peque√±as memorias internas muy r√°pidas que almacenan datos temporales, direcciones, contadores.</li>
<li>Contador de programa (PC o IP): apunta siempre a la pr√≥xima instrucci√≥n.</li>
</ul>
</li>
<li><strong>Memoria principal (RAM)</strong><ul>
<li>Contiene instrucciones y datos en la misma estructura lineal de direcciones.</li>
<li>Cada direcci√≥n apunta a una celda de memoria (generalmente un byte).</li>
<li>El programa y los datos est√°n mezclados, diferenciados solo por c√≥mo los usa la CPU.</li>
</ul>
</li>
<li><strong>Dispositivos de entrada</strong><ul>
<li>Permiten cargar datos en la computadora (teclado, lector de tarjetas perforadas en esa √©poca).</li>
</ul>
</li>
<li><strong>Dispositivos de salida</strong><ul>
<li>Permiten ver los resultados (impresora, pantalla, etc.).</li>
</ul>
</li>
<li><strong>Buses de comunicaci√≥n</strong><ul>
<li>Bus de direcciones: la CPU indica en qu√© celda de memoria quiere leer/escribir.</li>
<li>Bus de datos: transporta la informaci√≥n le√≠da o escrita.</li>
<li>Bus de control: se√±ales de sincronizaci√≥n (lectura/escritura, interrupciones, etc.).</li>
</ul>
</li>
</ol>
<h3 id="ciclo-basico-ciclo-de-instruccion">Ciclo b√°sico (ciclo de instrucci√≥n)</h3>
<ol>
<li>
<p>El ‚Äúlatido‚Äù de un computador von Neumann es el <strong>ciclo fetch‚Äìdecode‚Äìexecute</strong> (os debe sonar de lo explicado en el punto anterior):</p>
</li>
<li>
<p><strong>Fetch (captura):</strong></p>
<ul>
<li>El PC (Instruction Pointer en x86) da la direcci√≥n de la pr√≥xima instrucci√≥n.</li>
<li>La CPU la solicita a memoria a trav√©s del bus de direcciones. El contenido de esa direcci√≥n (un c√≥digo m√°quina) llega por el bus de datos a la CPU.</li>
</ul>
</li>
<li><strong>Decode (decodificaci√≥n):</strong><ul>
<li>La unidad de control interpreta ese c√≥digo binario y decide qu√© operaci√≥n ejecutar y qu√© recursos activar (ALU, registros, acceso a memoria).</li>
</ul>
</li>
<li><strong>Execute (ejecuci√≥n):</strong><ul>
<li>Se realiza la operaci√≥n: suma, movimiento de datos, salto, etc. Si el resultado debe almacenarse en memoria o un registro, se hace ahora.</li>
</ul>
</li>
<li><strong>Update (actualizaci√≥n):</strong><ul>
<li>Se incrementa el PC (IP en x86) para apuntar a la siguiente instrucci√≥n. El ciclo vuelve al paso 1.</li>
</ul>
</li>
</ol>
<p>Este proceso ocurre miles de veces por segundo en un 8086 y millones/miles de millones en procesadores modernos.</p>
<hr />
<h2 id="4-arquitectura-8086-de-16-bits-2-bytes">4. Arquitectura 8086 de 16 bits (2 bytes)</h2>
<p>Todo lo anterior eran ejemplos de este tipo de arquitectura. El 8086 es un procesador de 16 bits donde todos sus registros  son de 16 bits. Con 16 bits se pueden representar:
$$
2^{16}  \text{ bytes distintos} = 65.536 \text{ direcciones en la ram } = 65.536¬†, bytes= 64 \text{ KB}
$$
Eso significa: cada direcci√≥n de memoria en la ram se√±ala un byte, no un bit.</p>
<p>Ejemplo:</p>
<ul>
<li>Direcci√≥n <code>00000h</code> ‚Üí primer byte de RAM.</li>
<li>Direcci√≥n <code>00001h</code> ‚Üí segundo byte de RAM.</li>
<li>Direcci√≥n <code>00002h</code> ‚Üí tercer byte de RAM.</li>
</ul>
<p>Es decir, en teor√≠a, la RAM no deber√≠a tener m√°s de 64KB, porque no puedo acceder a registros de m√°s de 2 bytes. Sin embargo, en el 8086 el bus tiene 20 l√≠neas f√≠sicas de direcci√≥n (A0‚Ä¶A19). Con 20 l√≠neas se pueden generar:
$$
2^{20} = 1.048.576  \text{direcciones distintas} = 1 \text{ MB}
$$
Es por eso que la memoria m√°xima f√≠sica del 8086 es de 1 MB (1.048.576 bytes). Para direccionarla se necesitan 20 bits. Ahora bien, ¬øc√≥mo puedo acceder a direcciones de memoria mayores de 64kb en memoria si s√≥lo puedo guardar en registros de la CPU hasta 16 bits?</p>
<h3 id="41-la-solucion-de-intel-segmentacion">4.1 La soluci√≥n de Intel: segmentaci√≥n</h3>
<p>Como los registros son de 16 bits, no alcanzan para 20 bits. Intel invent√≥ el sistema de segmento:offset.</p>
<ul>
<li>Segmento (16 bits): contenido en CS, DS, SS o ES.</li>
<li>Offset (16 bits): valor en registros como IP, SP, BP, SI, DI o inmediato.</li>
<li>Direcci√≥n f√≠sica:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Direcci√≥n f√≠sica} = (\text{Segmento} \times 16) + \text{Offset}
</div>
<script type="math/tex; mode=display">
\text{Direcci√≥n f√≠sica} = (\text{Segmento} \times 16) + \text{Offset}
</script>
</div>
<p>El √ó16 = desplazar 4 bits a la izquierda : hace que los segmentos empiecen en m√∫ltiplos de 16. El offset puede variar hasta 64 KB. cada segmento cubre un bloque de 64 KB.</p>
<table>
<thead>
<tr>
<th>Tipo de registro en 8086 de 16 bits</th>
<th>Ejemplos</th>
<th>Uso principal</th>
<th>Ejemplo pr√°ctico</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Prop√≥sito general</strong></td>
<td>AX, BX, CX, DX</td>
<td>Guardar datos temporales y resultados de la ALU</td>
<td><code>MOV AX, 5</code>   <code>ADD AX, BX</code></td>
</tr>
<tr>
<td><strong>Segmento</strong></td>
<td>CS, DS, SS, ES</td>
<td>Seleccionar la base de un segmento de memoria (cada uno de 64 KB).</td>
<td><code>MOV AX, [DS:1234h]</code> ‚Üí Direcci√≥n f√≠sica = <code>DS√ó16 + 1234h</code></td>
</tr>
<tr>
<td><strong>Puntero de instrucci√≥n</strong></td>
<td>IP</td>
<td>Indica el offset de la pr√≥xima instrucci√≥n dentro de CS. Lo vemos con mas detalle en el punto 5.1</td>
<td>Si <code>CS=2000h</code> e <code>IP=0100h</code> ‚Üí Direcci√≥n f√≠sica = <code>2000h√ó16 + 0100h = 20100h</code></td>
</tr>
<tr>
<td><strong>Registros de pila</strong></td>
<td>SS, SP, BP</td>
<td>Controlar la pila (stack). <br/>‚Ä¢ <code>SS</code> = segmento de pila <br/>‚Ä¢ <code>SP</code> = tope de la pila (crece hacia abajo) <br/>‚Ä¢ <code>BP</code> = base pointer, usado en marcos de funciones</td>
<td><code>PUSH AX</code> guarda AX en <code>[SS:SP]</code> <br/><code>POP BX</code> saca de <code>[SS:SP]</code> <br/><code>MOV AX, [SS:BP-4]</code> accede a una variable local</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="5-como-se-carga-y-ejecuta-un-programa-en-un-8086">5. C√≥mo se carga y ejecuta un programa en un 8086</h2>
<p>Cuando ejecutas un programa en un 8086, lo primero que hace el sistema operativo (en MS-DOS, por ejemplo) es copiar el ejecutable desde el disco a la RAM. Ese ejecutable tiene un tama√±o concreto, definido cuando lo compilaste: puede ser de 20 KB, 100 KB o 200 KB, pero nunca ‚Äúinfinito‚Äù. El sistema reserva exactamente la memoria necesaria para tu c√≥digo, tus datos y la pila.</p>
<p>Veamoslo con un ejemplo. Supongamos que tu programa mide 200 KB. El 8086 no puede acceder directamente a todo el MB de memoria con un registro de 16 bits. Para resolver esto usamos lo visto anteriormente:</p>
<p>$$
\text{Direcci√≥n f√≠sica} = \text{Segmento} \times 16 + \text{Offset}
$$
Como el Offset es te 16 bits, nos permite acceder a 64kb m√°s de memoria desde el segmento base. De esta manera, la memoria del programa se organiza en ‚Äúcap√≠tulos‚Äù de 64 KB que pueden solaparse. Veamos el siguiente ejemplo SIN SOLAPAMIENTOS.</p>
<ul>
<li>
<table>
<thead>
<tr>
<th>Segmento</th>
<th>Direcci√≥n base</th>
<th>Tama√±o real</th>
<th>Explicaci√≥n clara</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>C√≥digo (CS1)</strong></td>
<td><code>2000h (se puede guardar en el registro porque 2000 tiene 16 bits)</code></td>
<td>64 KB</td>
<td>Aqu√≠ empieza la primera parte del programa. <strong>¬øPor qu√© no empieza en <code>1000h</code>?</strong>  Porque normalmente los programas no arrancan ‚Äúdonde caiga‚Äù: el cargador del sistema operativo los ubica en direcciones alineadas y libres, y <code>2000h</code> es una buena frontera. Adem√°s, <code>1000h</code> podr√≠a estar ocupado por BIOS, vectores de interrupci√≥n o datos del sistema.</td>
</tr>
<tr>
<td><strong>C√≥digo (CS2)</strong></td>
<td><code>3000h</code></td>
<td>56 KB (de los 64 disponibles)</td>
<td>El c√≥digo era m√°s grande que 64 KB (el l√≠mite de un segmento), as√≠ que se parti√≥ en <strong>otro bloque</strong>. Se reserva todo el segmento, pero solo se usan 56 KB. El resto queda vac√≠o o sin usar.</td>
</tr>
<tr>
<td><strong>Datos (DS)</strong></td>
<td><code>4000h</code></td>
<td>64 KB</td>
<td>Aqu√≠ van variables globales y datos est√°ticos. Usamos un segmento completo porque los programas suelen necesitar bastante espacio para datos, y as√≠ es m√°s f√°cil direccionarlos con <code>DS</code>.</td>
</tr>
<tr>
<td><strong>Pila (SS)</strong></td>
<td><code>5000h</code></td>
<td>16 KB</td>
<td>El segmento de pila podr√≠a ser de hasta 64 KB, porque <code>SP</code> (stack pointer) puede contar de <code>0000h</code> a <code>FFFFh</code>. Pero no siempre hace falta. En este programa se reservaron 16 KB, suficiente para guardar direcciones de retorno (2 bytes por llamada), registros salvados y variables locales. Reservar 64 KB ser√≠a un desperdicio de memoria, sobre todo en PCs de 256 KB o 640 KB de RAM.</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="51-ejecucion-de-instrucciones">5.1 Ejecuci√≥n de instrucciones</h3>
<p>El flujo de tu programa comienza en <code>CS:IP</code>:</p>
<ul>
<li><code>CS</code> marca el bloque de c√≥digo.</li>
<li><code>IP</code> se√±ala la primera instrucci√≥n dentro de ese bloque.</li>
</ul>
<p>La CPU lee la instrucci√≥n, la ejecuta y despu√©s incrementa <code>IP</code> en tantos bytes como mida esa instrucci√≥n. Por ejemplo, si <code>IP=0100h</code> y la instrucci√≥n ocupa 3 bytes, al acabar <code>IP=0103h</code>, es decir, b√°sicamente suma 3 bytes para pasar a la siguiente instrucci√≥n.</p>
<h3 id="52-la-pila-de-ejecucion">5.2 La pila de ejecuci√≥n</h3>
<p>El stack o pila es otra parte reservada en RAM. Est√° controlada por <code>SS:SP</code>.<code>SS</code> se√±ala el segmento de pila y <code>SP</code> es el puntero que va subiendo y bajando.</p>
<p>La pila funciona como una estructura LIFO:</p>
<ul>
<li>Cada <code>PUSH</code> reduce <code>SP</code> y guarda un valor en memoria.</li>
<li>Cada <code>POP</code> aumenta <code>SP</code> y recupera el valor.</li>
</ul>
<p>Esto se usa para guardar direcciones de retorno en las llamadas a funciones (<code>CALL</code> / <code>RET</code>) y tambi√©n para variables locales o registros temporales.</p>
<hr />
<h2 id="6-ejemplo-de-estructura-lifo">6 Ejemplo de estructura LIFO</h2>
<ul>
<li><strong>SS = 5000h</strong>
   ‚Äúmi pila vive en el segmento de memoria 5000h‚Äù. (¬øPor qu√© se llamaba segmento?)</li>
<li><strong>Tama√±o que reservo para la pila = 16 KB</strong>
   16 KB = <code>4000h</code> bytes dentro de ese segmento.</li>
<li><strong>SP inicial = 4000h</strong>
    significa ‚Äúla pila est√° vac√≠a y lista para empezar a llenarse hacia abajo‚Äù.</li>
</ul>
<blockquote>
<p>Nota: <code>SP</code> no ‚Äútiene‚Äù que ser 4000h; lo pongo as√≠ <strong>porque he reservado 16 KB</strong>.</p>
</blockquote>
<h3 id="61-estado-inicial-vacio">6.1. Estado inicial (vac√≠o)</h3>
<div class="highlight"><pre><span></span><code>SP = 4000h   ‚Üê pila vac√≠a (16 KB reservados)
</code></pre></div>
<h3 id="62-hacemos-dos-push">6.2. Hacemos dos PUSH</h3>
<div class="highlight"><pre><span></span><code>MOV AX, 1234h
PUSH AX      ; guarda 1234h

MOV BX, 5678h
PUSH BX      ; guarda 5678h
</code></pre></div>
<h3 id="63-miramos-como-se-guarda-la-informacion-en-cada-direccion-de-memoria">6.3. Miramos como se guarda la informacion en cada direcci√≥n de memoria:</h3>
<div class="highlight"><pre><span></span><code>Direcci√≥n   Contenido
5000:3FFC   78h   ‚Üê byte bajo de BX
5000:3FFD   56h   ‚Üê byte alto de BX
5000:3FFE   34h   ‚Üê byte bajo de AX
5000:3FFF   12h   ‚Üê byte alto de AX
SP = 3FFCh
</code></pre></div>
<p>üëâObserva 3 cosas importantes:</p>
<ol>
<li><strong>BX (5678h)</strong> qued√≥ m√°s arriba en la pila porque fue el √∫ltimo en entrar.</li>
<li><strong>AX (1234h)</strong> qued√≥ m√°s abajo, porque entr√≥ primero.</li>
<li><code>SP = 3FFCh</code> ‚Üí apunta al inicio del √∫ltimo valor guardado (BX).</li>
</ol>
<p>Esto refleja la regla LIFO (<strong>Last In, First Out</strong>): el √∫ltimo en entrar ser√° el primero en salir.</p>
<h3 id="64-hacemos-un-pop">6.4. Hacemos un POP</h3>
<p>Ejecutamos:</p>
<div class="highlight"><pre><span></span><code>POP CX
</code></pre></div>
<p>Es la instrucci√≥n que:</p>
<ol>
<li>Toma el valor que est√° arriba de la pila (16 bits = 2 bytes).</li>
<li>Lo coloca en el registro CX.</li>
<li>
<p>Ajusta <code>SP</code> subiendo 2 posiciones, dejando la pila un poco m√°s ‚Äúvac√≠a‚Äù.</p>
</li>
<li>
<p>La CPU lee los 2 bytes en <code>3FFCh</code> y <code>3FFDh</code>: <code>78h</code> (bajo), <code>56h</code> (alto) ‚Üí <code>CX = 5678h</code>. <code>SP</code> sube en 2 ‚Üí <code>SP = 3FFEh</code>.</p>
</li>
</ol>
<p>Estado de la pila ahora:</p>
<div class="highlight"><pre><span></span><code>Direcci√≥n   Contenido
5000:3FFE   34h   ‚Üê byte bajo de AX
5000:3FFF   12h   ‚Üê byte alto de AX
SP = 3FFEh
CX = 5678h
</code></pre></div>
<h2 id="3-nucleos-y-threads-hilos">3. N√∫cleos y threads (hilos)</h2>
<h3 id="1-cpu">1. CPU</h3>
<p>Una CPU lo √∫nico que sabe hacer es ejecutar instrucciones: sumar, restar, mover datos, saltar a otra parte del programa‚Ä¶, un programa normal est√° compuesto por miles o millones de estas instrucciones que se ejecutan una tras otra. </p>
<ol>
<li>Un programa es un conjunto finito y ordenado de instrucciones codificadas, escritas en un lenguaje de programaci√≥n y almacenadas en un archivo ejecutable o script.</li>
</ol>
<p>Ese archivo define qu√© hacer, pero no lo est√° haciendo hasta que se carga en memoria. Contiene:</p>
<ul>
<li>C√≥digo: secuencia de instrucciones m√°quina.</li>
<li>Datos est√°ticos: constantes, literales, recursos.</li>
<li>Estructuras de estado inicial: tablas de s√≠mbolos, direcciones de memoria preasignadas, etc.</li>
</ul>
<p>‚Äã    Cuando lo cargas y el sistema operativo lo arranca, se convierte en un proceso.</p>
<ol>
<li>
<p>Un proceso es una instancia en ejecuci√≥n de un programa, gestionada por el sistema operativo.</p>
</li>
<li>
<p>Se le asignan recursos: espacio de direcciones en memoria, descriptores de archivos, registros de CPU, hilos de ejecuci√≥n. Mantiene un contexto de ejecuci√≥n:</p>
</li>
<li>
<p>Contador de programa (PC) IInstruction pointer visto antes)</p>
</li>
<li>Registros de CPU</li>
<li>Pila (stack)</li>
<li>Informaci√≥n de planificaci√≥n (prioridad, estado de bloqueo/ejecuci√≥n).</li>
</ol>
<p>Aqu√≠ ya adquiere un contexto de ejecuci√≥n (memoria asignada, hilos, registros  inicializados‚Ä¶). </p>
<ol>
<li>Un demonio es un tipo especial de proceso en sistemas tipo Unix/Linux que: </li>
</ol>
<p>Se ejecuta en segundo plano y no est√° asociado a un terminal ni a la interacci√≥n directa del usuario. Normalmente se inicia al arrancar el sistema y permanece activo para proporcionar servicios al sistema o a otros procesos. Uno de los m√°s comunes que utilizaremos ser√° cron. cron = ‚Äúreloj despertador‚Äù que ejecuta tareas a horas programadas.</p>
<h3 id="2-flujo-de-ejecucion">2. Flujo de ejecuci√≥n</h3>
<p>Un flujo de ejecuci√≥n es simplemente esa secuencia de instrucciones que se ejecutan una detr√°s de otra. Si tuvieras una CPU muy simple, solo podr√≠as ejecutar un flujo de ejecuci√≥n a la vez: empieza en la instrucci√≥n 1, luego la 2, la 3‚Ä¶ y as√≠ hasta terminar. </p>
<h3 id="3-thread-hilo">3. Thread. Hilo</h3>
<p>Un hilo es un flujo de ejecuci√≥n con su propio contexto:</p>
<ul>
<li>
<p>Tiene su propio contador de programa (sabe en qu√© instrucci√≥n va).  Registro especial de la CPU que contiene la direcci√≥n de memoria de la siguiente instrucci√≥n que se debe ejecutar, adem√°s, tiene su propio conjunto de registros  (los registros f√≠sicos est√°n en el n√∫cleo del procesador)</p>
</li>
<li>
<p>Tambi√©n, puede avanzar de manera independiente respecto a otros hilos.</p>
</li>
<li>
<p>Es importante recalcar que los hilos viven dentro de un proceso. Comparten la misma memoria y recursos del proceso padre, como: variables globales, archivos abiertos, etc.</p>
</li>
</ul>
<p>Como ya hemos dicho, cada hilo tiene su propio contador de programa y pila, as√≠ que pueden ejecutar partes diferentes del c√≥digo al mismo tiempo. Como comparten memoria, deben usar mecanismos de sincronizaci√≥n (locks, sem√°foros, colas seguras, lo vemos en el ejemplo de python) </p>
<p><u>Eso significa que dentro de un mismo programa puedes tener varios hilos que hacen cosas distintas en paralelo.</u></p>
<h3 id="4-core">4. Core</h3>
<p>Un n√∫cleo de CPU es una unidad de procesamiento completa dentro de un chip.
 Lo puedes imaginar como un procesador independiente que forma parte de un procesador m√°s grande (multi-core).</p>
<p>Cada n√∫cleo puede ejecutar su propio flujo de instrucciones (hilo) de manera independiente, porque tiene sus propios componentes internos</p>
<ul>
<li>Tiene su propia ALU (suma/resta), FPU (coma flotante), CU (Control Unit) pila de ejecuci√≥n.</li>
<li>Si tienes 1 n√∫cleo, solo puede ejecutar un hilo a la vez. Si tienes 4 n√∫cleos, puede ejecutar 4 hilos a la vez de verdad, porque son 4 bloques f√≠sicos de ejecuci√≥n.</li>
</ul>
<p>Cada n√∫cleo de CPU no solo tiene sus unidades de c√°lculo, tambi√©n cuenta con memoria cach√©** para reducir la latencia al acceder a datos e instrucciones y no tener que pasar por la ram:</p>
<ul>
<li><strong>Cach√© L1</strong>:</li>
</ul>
<p>La m√°s peque√±a (32‚Äì64 KB normalmente) y la m√°s r√°pida. Se divide en dos: <em>L1 Data Cache</em> (para datos) y <em>L1 Instruction Cache</em> (para instrucciones). Est√° dentro del n√∫cleo.
- <strong>Cach√© L2</strong>:</p>
<p>M√°s grande (256 KB ‚Äì 1 MB por n√∫cleo) y un poco m√°s lenta que L1. Tambi√©n suele ser privada de cada n√∫cleo.
- <strong>Cach√© L3</strong>:</p>
<p>Mucho m√°s grande (varios MB). Es compartida entre todos los n√∫cleos de un mismo procesador. Sirve de ‚Äúalmac√©n com√∫n‚Äù para coordinar la informaci√≥n entre n√∫cleos.</p>
<h3 id="5-hyperthreading-smt">5. HyperThreading / SMT</h3>
<p>Los ingenieros se dieron cuenta de que un n√∫cleo muchas veces est√° ocioso esperando datos de la RAM o de un disco. Para no perder tiempo, dise√±aron un mecanismo donde un n√∫cleo puede mantener dos contextos de hilos (dos contadores de programa, dos juegos de registros) y alternar instrucciones de ambos.</p>
<ul>
<li>As√≠, un √∫nico n√∫cleo ‚Äúfinge‚Äù ser dos hilos l√≥gicos y para el sistema operativo, parece que hay 2 procesadores.</li>
<li>En realidad, los dos comparten el mismo hardware y compiten por recurso</li>
</ul>
<p>Distinguimos pues, dos tipos de n√∫cleos:</p>
<ul>
<li><strong>N√∫cleo f√≠sico</strong>: lo que acabamos de describir. Es hardware real, con todos esos componentes.</li>
<li>N√∫cleo l√≥gico (SMT / HyperThreading): un n√∫cleo f√≠sico que mantiene dos contextos de registros y PC. Permite ejecutar <em>dos hilos de software</em> como si fueran dos CPUs, compartiendo las mismas ALU/FPU.</li>
</ul>
<p>Un n√∫cleo l√≥gico no duplica la ALU, solo aprovecha mejor los tiempos muertos del n√∫cleo f√≠sico.</p>
<h3 id="6-que-hace-el-programa-firefox">6. ¬øQu√© hace el programa Firefox?</h3>
<p>Cuando ejecutas un programa como Firefox, no se lanza un √∫nico proceso simple, sino varios procesos diferentes. Hay un proceso principal (PPID), que controla la interfaz y coordina el resto (PID), y despu√©s otros procesos auxiliares: cada pesta√±a suele tener su propio proceso de contenido, existe un proceso para la GPU, otro para plugins, y algunos m√°s para aislamiento y seguridad.</p>
<p>Dentro de cada uno de esos procesos, adem√°s, no corre un √∫nico hilo: se crean m√∫ltiples hilos internos que se encargan de tareas concretas. Por ejemplo, unos hilos gestionan la red, otros se ocupan de renderizar p√°ginas, otros manejan la ejecuci√≥n de JavaScript, y otros procesan audio o v√≠deo. Todo esto ocurre de forma autom√°tica, aunque el usuario no lo vea.</p>
<h3 id="7-simulando-concurrencia-y-paralelismo-en-un-lenuaje-de-programacion-python">7. Simulando concurrencia y paralelismo en un lenuaje de programaci√≥n. Python</h3>
<p>En Python hay dos librer√≠as principales para trabajar con concurrencia:</p>
<ul>
<li><code>threading</code>: crea hilos de software gestionados por el int√©rprete. </li>
<li><code>multiprocessing</code>: crea procesos independientes, cada uno con su propio int√©rprete Python.</li>
</ul>
<hr />
<h1 id="ejemplo-tecnico-en-python">Ejemplo t√©cnico en Python</h1>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="k">def</span><span class="w"> </span><span class="nf">tarea</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tarea </span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s2"> ejecut√°ndose en PID </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Simulaci√≥n de trabajo pesado (CPU-bound)</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Tarea </span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s2"> termin√≥ con suma=</span><span class="si">{</span><span class="n">suma</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Detectamos n¬∫ de CPUs l√≥gicas (n√∫cleos √ó hilos por n√∫cleo con SMT/HT)</span>
    <span class="n">hilos_logicos</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Procesadores l√≥gicos detectados: </span><span class="si">{</span><span class="n">hilos_logicos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Creamos un pool de procesos igual a los hilos l√≥gicos de 8 procesos</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">hilos_logicos</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">resultados</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">tarea</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">resultados</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</code></pre></div>
<p><strong><code>cpu_count()</code></strong></p>
<p>Pregunta al sistema operativo cu√°ntos <em>procesadores l√≥gicos</em> hay disponibles. Si tienes 4 n√∫cleos con HyperThreading, devuelve 8.</p>
<p><strong><code>Pool(processes=hilos_logicos)</code></strong></p>
<ul>
<li>Crea un conjunto de procesos hijo, tendran PPID del proceso padre.</li>
<li>Cada proceso es independiente, con su propio int√©rprete Python y su propio espacio de memoria.</li>
<li>El sistema operativo los distribuye entre los n√∫cleos f√≠sicos y los hilos de hardware.</li>
</ul>
<p><strong><code>pool.map(tarea, range(8))</code></strong></p>
<p>Lanza 8 tareas que se ejecutan concurrentemente. Si tienes 8 procesadores l√≥gicos, todas corren a la vez. Si tienes menos , el sistema operativo hace <em>scheduling</em> y las alterna.</p>
<p>Como son procesos independientes, aqu√≠ s√≠ se aprovechan los varios n√∫cleos de la CPU. Si tu CPU soporta SMT, entonces algunos procesos pueden compartir un n√∫cleo f√≠sico mediante HyperThreading. Vemos el siguiente ejemplo</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">threading</span><span class="o">,</span><span class="w"> </span><span class="nn">queue</span><span class="o">,</span><span class="w"> </span><span class="nn">time</span><span class="o">,</span><span class="w"> </span><span class="nn">random</span>

<span class="n">buffer</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">productor</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;item-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">buffer</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>  <span class="c1"># se bloquea si est√° llena</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">threading</span><span class="o">.</span><span class="n">get_native_id</span><span class="p">()</span><span class="si">}</span><span class="s2">] Produjo: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> (buffer=</span><span class="si">{</span><span class="n">buffer</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># produce muy r√°pido</span>

<span class="k">def</span><span class="w"> </span><span class="nf">consumidor</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  <span class="c1"># se bloquea si est√° vac√≠a</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">threading</span><span class="o">.</span><span class="n">get_native_id</span><span class="p">()</span><span class="si">}</span><span class="s2">] Consumi√≥: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> (buffer=</span><span class="si">{</span><span class="n">buffer</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># consume m√°s lento</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">productor</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumidor</span><span class="p">)</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div>
<p>El ejemplo anterior (<code>multiprocessing.Pool</code>) usaba procesos, cada uno con su propio espacio de memoria. Este ejemplo usa hilos, comparten memoria, y por eso necesitan sincronizaci√≥n.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>